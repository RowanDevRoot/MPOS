import { directive, NodePart } from 'lit-html';

const DEFAULT_TRANSITION_PROPERTY_VALUE = 'all 0s ease 0s';
const DEFAULT_ANIMATION_PROPERTY_VALUE = 'none 0s ease 0s 1 normal none running';

const notEqual = a => b => a !== b;
const trim = str => str.trim();
const isElementNode = ({ nodeType }) => nodeType === 1;
const switchClasses = (node, actions) =>
  Object.entries(actions).forEach(([fn, v]) => {
    if (v) {
      node.classList[fn](v);
    }
  });
const onEventFactory = element => eventName =>
  new Promise(resolve =>
    element.addEventListener(eventName, function cb(event) {
      resolve(event);
      event.currentTarget.removeEventListener(event.type, cb); // once (ie11 support);
    }),
  );
const onRaceEventsFactory = eventsNames => element =>
  Promise.race(eventsNames.map(onEventFactory(element)));
const onAnimated = onRaceEventsFactory(['animationend', 'animationcancel']);
const onTransitioned = onRaceEventsFactory(['transitionend']);

const getPropertyValueFactory = element => {
  const cs = document.defaultView.getComputedStyle(element);
  return property => cs.getPropertyValue(property).split(',').map(trim);
};

const onEndAction = element => {
  const getPropertyValue = getPropertyValueFactory(element);
  const transitioned = getPropertyValue('transition')
    .filter(notEqual(DEFAULT_TRANSITION_PROPERTY_VALUE))
    .map(() => onTransitioned(element));
  const animated = getPropertyValue('animation')
    .filter(notEqual(DEFAULT_ANIMATION_PROPERTY_VALUE))
    .map(() => onAnimated(element));
  return Promise.all(animated.concat(transitioned));
};

const getCurrentNodes = part => {
  const db = [];
  if (part.startNode.nextSibling === part.endNode) {
    // is empty
    return db;
  }
  let node = part.startNode.nextSibling;
  while (node !== part.endNode) {
    db.push(node); // assign and set
    node = node.nextSibling;
  }

  return db;
};

const getCurrentElementNodes = part => getCurrentNodes(part).filter(isElementNode);

export const swapTransition = directive(
  (newNode, { add = 'visible', remove = 'hidden' } = {}) => part => {
    /* istanbul ignore next */
    if (!(part instanceof NodePart)) {
      throw new Error('SwapTransition can only be used in content bindings');
    }
    const isEmpty = part.startNode.nextSibling === part.endNode;
    const commit = () => {
      part.setValue(newNode);
      part.commit();
      getCurrentElementNodes(part).forEach(node => {
        setTimeout(() => {
          switchClasses(node, { add, remove });
        }, 0);
      });
    };
    if (isEmpty) {
      commit();
    } else {
      getCurrentElementNodes(part).forEach(node => {
        switchClasses(node, { add: remove, remove: add });
      });
      onEndAction(part.endNode.previousSibling).then(commit);
    }
  },
);
