import { html, fixture, assert, fixtureCleanup } from '@open-wc/testing';
import { BbvaCoreMeta } from '../index.js';

suite('BbvaCoreMeta', () => {
  let el;

  teardown(() => fixtureCleanup());

  setup(async () => {
    el = await fixture(html`<bbva-core-meta></bbva-core-meta>`);
    await el.updateComplete;
  });

  suite('init', () => {
    test('byKey', () => {
      const meta = new BbvaCoreMeta({ key: 'info', value: 'foo/bar', });
      assert.equal(meta.value, 'foo/bar');
    });

    test('list', () => {
      const meta = new BbvaCoreMeta({ key: 'info', value: 'foo/bar', });
      assert.equal(meta.list.length, 1);
    });

    test('getting `list` does not throw if no objects of the given type exist', () => {
      const meta = new BbvaCoreMeta({ type: 'NO ITEMS OF THIS TYPE', });
      assert.doesNotThrow(() => {
        // eslint-disable-next-line no-unused-expressions
        meta.list;
      });
    });

    test('constructor with no arguments', () => {
      assert.doesNotThrow(() => {
        // eslint-disable-next-line no-new
        new BbvaCoreMeta();
      });
    });
  });

  suite('basic behavior', () => {
    let meta;

    setup(() => {
      meta = new BbvaCoreMeta({ key: 'info', value: 'foo/bar', });
    });

    teardown(() => {
      meta.value = null;
    });

    test('can be assigned alternative values', () => {
      meta.value = 'foobar';
      meta.value = 'barfoo';
      assert.equal(meta.list[0], 'barfoo');
    });

    test('can access same-type meta values by key', () => {
      assert.equal(meta.byKey(meta.key), meta.value);
    });

    test('yields a list of same-type meta data', () => {
      assert.isArray(meta.list);
      assert.equal(meta.list.length, 1);
      assert.equal(meta.list[0], 'foo/bar');
    });
  });

  suite('many same-typed metas', () => {
    let metas = [];

    setup(() => {
      metas[0] = new BbvaCoreMeta({ key: 'default1', value: 'foo/bar1', });
      metas[1] = new BbvaCoreMeta({ key: 'default2', value: 'foo/bar2', });
      metas[2] = new BbvaCoreMeta({ key: 'default3', value: 'foo/bar3', });
    });

    teardown(() => {
      metas.forEach(function(meta) {
        meta.value = null;
        meta.key = null;
      });
    });

    test('all cache all meta values', () => {
      metas.forEach(function(meta) {
        assert.equal(meta.list.length, metas.length);
        assert.operator(meta.list.indexOf(meta.value), '>=', 0);
      });
    });

    test('can be unregistered individually', () => {
      metas[0].value = null;
      assert.equal(metas[0].list.length, 2);
      assert.includeMembers(metas[0].list, ['foo/bar2', 'foo/bar3',]);
    });

    test('can access each others value by key', () => {
      assert.equal(metas[2].byKey('default2'), metas[1].value);
    });

    test('when access to other value by key, not lose your value', () => {
      assert.equal(metas[2].byKey('default1'), metas[0].value);
      assert.equal(metas[2].value, 'foo/bar3');
    });
  });

  suite('different-typed metas', () => {
    let metasType = [];

    setup(() => {
      metasType[0] = new BbvaCoreMeta({ type: 'foo', key: 'foobarKey', value: 'type/foo', });
      metasType[1] = new BbvaCoreMeta({ type: 'bar', key: 'foobarKey', value: 'type/bar', });
    });

    teardown(() => {
      metasType.forEach(function(meta) {
        meta.value = null;
        meta.key = null;
      });
    });

    test('cache their values separately', () => {
      const fooMeta = metasType[0];
      const barMeta = metasType[1];

      assert.notEqual(fooMeta.value, barMeta.value);
      assert.equal(fooMeta.byKey('foobarKey'), fooMeta.value);
      assert.equal(barMeta.byKey('foobarKey'), barMeta.value);
    });


    test('only list values of their type', () => {
      metasType.forEach(function(meta) {
        assert.equal(meta.list.length, 1);
        assert.equal(meta.list[0], meta.value);
      });
    });
  });

  suite('metas with clashing keys', () => {
    let metaPair = [];

    setup(() => {
      metaPair[0] = new BbvaCoreMeta({ key: 'baz', value: 'baz/1', });
      metaPair[1] = new BbvaCoreMeta({ key: 'baz', value: 'baz/2', });
    });

    teardown(() => {
      metaPair.forEach(function(meta) {
        meta.value = null;
        meta.key = null;
      });
    });

    test('let the last value win registration against the key', () => {
      const registeredValue = metaPair[0].byKey(metaPair[0].key);
      const firstValue = metaPair[0].value;
      const secondValue = metaPair[1].value;
      assert.equal(firstValue, secondValue);
      assert.equal(registeredValue, secondValue);
    });
  });
});
