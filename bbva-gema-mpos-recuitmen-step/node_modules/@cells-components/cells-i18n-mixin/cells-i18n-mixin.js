import { dedupingMixin } from '@cells-components/cells-lit-helpers/utils/mixin.js';
import '@cells-components/cells-shadow-query-selector/cells-shadow-query-selector.js';
import LocalesService from './locales-service.js';
/**

cells-i18n-mixin
=======================

`CellsMixins.i18nMixin` provides a normalized interface for translate strings.

## Import

1) Import the mixin in your component:

2) Use `CellsI18nMixin` to extend from it in the class definition of your component:

```js
class MyElement extends CellsI18nMixin(LitElement) {
  static get is() { return 'my-element' }
}
 ```

## Usage

**string-to-translate** is the key to the string or message ('locale') in the corresponding language, in your **locales/{lang}.json** files.

 __Note:__ It is recommended that the keys have the name of the component as suffix. E.g. 'cells-basic-login-greeting' or 'cells-basic-login-username'

 1. Basic usage (binding)

    ```js
    ${this.doTranslation('string-to-translate')}
    ```

    or, in a shorter but equivalent way (t() is just an alias of doTranslation()):

    ```js
    ${this.t('string-to-translate')}
    ```

 2. Define an optional 'fallback' string with the second parameter (the **Fallback string** will display if **string-to-translate** key doesn't exist in 'locales'.)

    ```js
    ${this.t('string-to-translate', 'Fallback string')}
     ```

 3. For asynchronous translation on connectedCallback:

    ```js
    connectedCallback() {
      super.connectedCallback();
      this.getMsg('string-to-translate').then((translation) => {
        this.set('readyTranslation', translation);
      });
    }
    ```

 4. Define an optional 'interpolation' string object with the third parameter::

    ```js
    ${this.t('string-to-translate', '', '{"attribute": "value"}')
     ```

    Interporlation object can be self properties:

    ```js
    ${this.t('string-to-stranslate-with-ref-to-self-property')
    ```

__Note:__ If **string-to-translate** contains a comma (,) it must be escaped by preceding it with a '\'

Example:

```js
<p>
 ${this.t('Welcome')}
 <input type="text" placeholder="${this.t('Username, Email or UserID')}">
</p>
```

## Locales (translations)

Finally, have the translations for each language on the *locales* folder.

This folder will have one JSON file for each supported language (en.json, es.json, en-US.json, etc).

For every language the Object defined contains all translated strings indexed by a unique ID, which is the same across all languages.

***en.json:***

```json
{
  "your-component-name-cancel": { // valid legacy syntax
    "message": "Cancel"
  },
  "your-component-name-info": "Information", //simple syntax
  "explicitText": { "${attribute}, hello!" }, // interpolated variable
  "some-key": { "Bye {{attribute}}" }, // alternative supported syntax for interpolation
  "arrayText": ["part1", "part2", "...", "partN"],
  "self-property-msg": "My property value is ${propertyName}"
}
```

***es.json:***

```json
{
  "your-component-name-cancel": "Cancelar", //simple syntax
  "explicitText": { "Hola ${attribute}!" },
  "arrayText": ["part1", "part2", "...", "partN"]
}
```

### Multilevel JSON

JSON with nested keys are supported, however it's encouraged not to use it in standalone components to prevent accidental overrides that may occur when the translation files of the components are merged into a single file in a Cells application. JSON with nested keys are intended to be used in applications (locales-app) and _in-app_ components. Requires setting `unFlattened` in `window.I18nMsg` to `true`.

```js
  window.I18nMsg = window.I18nMsg || {};
  window.I18nMsg.unFlattened = true;
```

### Locale file names

Different file names that those that correspond with the `lang` attribute of the document are supported.
Using it requires setting `files` array property in `window.I18nMsg`. **This feature should not be used in standalone components**. As with multilevel JSON, it is intented to be used in applications.

```js
  window.I18nMsg = window.I18nMsg || {};
  window.I18nMsg.files = ['eng.json', 'spa.json'];
```

## Disable translations

To disable the translation functionality (for instance, in applications that don't have locales folder), set `window.I18nMsg.disabled` to `true` to
prevent network requests to non-existent locales files.

In your main html file (index.html):

```js
  window.I18nMsg = window.I18nMsg || {};
  window.I18nMsg.disabled = true;
```

## Disable caching locales

To disable the default caching of locales and force the behaviour to fetch them every time, just set window.I18nMsg.noCache to `true`.

In your main html file (index.html):

```js
  window.I18nMsg = window.I18nMsg || {};
  window.I18nMsg.noCache = true;
```

* @mixinFunction
* @demo demo/index.html
* @hero cells-i18n-mixin.png
*/
export const CellsI18nMixin = dedupingMixin(superClass => {
  return class extends superClass {
    constructor() {
      super();
      this.hasI18n = true;
    }

    static get properties() {
      return {
        /**
         * Puts a readonly attribute to the component to mark this node has i18n.
         * @private
         */
        hasI18n: {
          type: Boolean,
          reflect: true,
          attribute: 'has-i18n'
        }
      };
    }

    /**
     * The `i18n-language-ready` is fired in `document` after the locale was fetched.
     *
     * @event i18n-language-ready
     * @detail {{language: String}}
     */

    /**
     * Fired when language of global Object (I18nMsg) changes
     * @event i18n-lang-changed
     */

    doTranslation(msgId, fallback, interpolation) {
      return this._doTranslation(msgId, fallback, interpolation);
    }

    t(...args) {
      return this._doTranslation(...args);
    }

    /**
     * Refresh the printed translated text with the current language.
     */
    updateTranslation() {
      this.requestUpdate();
    }

    /**
     * Translates a string to the current language from html code.
     *
     * @param {String} msgId String id to translate.
     * @param {String} fallback (optional) A string to be returned if {{msgId}} doesn't exists in the dictionary. If this param is not defined and the translated text doesn't exists, the original {{msgId}} is returned.
     * @param {String|Object} interpolation  (optional) Object or String for interpolate
     *
     * @return {String} Translated text. If it doesn't exists, returns a fallback text.
     */
    _doTranslation(msgId, fallback, interpolation) {
      const text = I18nMsg.getTranslation(msgId) || fallback;

      if (text) {
        return this._transform(text, interpolation || {});
      }

      return msgId;
    }

    /**
     * getAsyncTranslation() alias
     */
    getMsg(msgId, interpolation) {
      return this.getAsyncTranslation(msgId, interpolation);
    }

    /**
     * Translates a string when the dictionary is loaded from the js.
     *
     * @param {String} msgId          (optional) String id to translate.
     * @param {String} interpolation  (optional) Object String for interpolate variables.
     *
     * @return {Promise} Returns a Promise that is resolved when the dictionary is ready.
     */
    getAsyncTranslation(msgId, interpolation) {
      return I18nMsg.translationsRequests.then(() => this.getTranslation(msgId, interpolation));
    }

    /**
     * Translates a string to the current language.
     *
     * @param  {String}           msgId String to translate.
     * @param  {String | Object} interpolation  (optional) Object String for interpolate
     * @return {String}           Translated text. If it doesn't exists, returns null.
     */
    getTranslation(msgId, interpolation) {
      const msg = I18nMsg.getTranslation(msgId);

      if (msg) {
        return this._transform(msg, interpolation);
      }

      return null;
    }

    _transform(msg, interpolation) {
      let translatedString = msg;

      if (Array.isArray(msg)) {
        translatedString = msg.join('');
      } else if (msg.message) {
        translatedString = msg.message;
      }

      const parsedInterpolation = this._parseInterpolation(interpolation);
      if (parsedInterpolation) {
        return this._interpolateMsg(translatedString, parsedInterpolation);
      }

      return translatedString;
    }

    _parseInterpolation(interpolation) {
      if (interpolation !== '') {
        try {
          if (typeof interpolation === 'string') {
            interpolation = JSON.parse(decodeURI(interpolation));
          }
        } catch (e) {
          interpolation = '';
        }

        return interpolation;
      }
    }

    _interpolateMsg(msg, interpolation) {
      msg = this._pluralize(msg, interpolation);

      if (!msg || typeof msg === 'object') {
        return '';
      }

      const useRegexp = (msg.indexOf('${') > -1) ? /\${(.*?)}/g : /\{\{(.*?)}}/g;

      return msg.replace(useRegexp, (_, code) => {
        return code in interpolation ? interpolation[code] : this[code];
      });
    }

    _pluralize(msg, interpolation) {
      let msgResult = msg;

      if (interpolation.count !== undefined && msg.one && msg.other) {
        msgResult = interpolation.count === 1 ? msg.one : msg.other;
      }

      return msgResult;
    }
  };
});


(function(window) {
  window.I18nMsg = window.I18nMsg || {};
  /* eslint-disable read-only, no-global-assign */
  if (window.I18nMsg instanceof LocalesService) {
    return;
  }

  window.I18nMsg = new LocalesService(window.I18nMsg);
  /* eslint-enable read-only, no-global-assign */
  window.I18nMsg.fetchLanguage();
}(window));
