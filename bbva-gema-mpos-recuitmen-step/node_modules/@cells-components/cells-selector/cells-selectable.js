/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
import { LitElement, } from 'lit-element';
import { dedupingMixin, } from '@cells-components/cells-lit-helpers/utils/mixin.js';
import { FlattenedNodesObserver } from '@cells-components/cells-lit-helpers/utils/flattened-nodes-observer.js';
import { CellsSelection } from './cells-selection.js';

/**
 * @mixinFunction
 */
export const CellsSelectableMixin = dedupingMixin(superClass => {
  return class extends superClass {

    /**
     * Fired when cells-selector is activated (selected or deselected).
     * It is fired before the selected items are changed.
     * Cancel the event to abort selection.
     *
     * @event cells-activate
     */

    /**
     * Fired when an item is selected
     *
     * @event cells-select
     */

    /**
     * Fired when an item is deselected
     *
     * @event cells-deselect
     */

    /**
     * Fired when the list of selectable items changes (e.g., items are
     * added or removed). The detail of the event is a mutation record that
     * describes what changed.
     *
     * @event cells-items-changed
     */

    static get properties() {
      return {
        /**
         * If you want to use an attribute value or property of an element for
         * `selected` instead of the index, set this to the name of the attribute
         * or property. Hyphenated values are converted to camel case when used to
         * look up the property of a selectable element. Camel cased values are
         * *not* converted to hyphenated values for attribute lookup. It's
         * recommended that you provide the hyphenated form of the name so that
         * selection works in both cases. (Use `attr-or-property-name` instead of
         * `attrOrPropertyName`.)
         */
        attrForSelected: {
          type: String,
          attribute: 'attr-for-selected'
        },

        /**
         * Gets or sets the selected element. The default is to use the index of the
         * item.
         * @type {string|number}
         */
        selected: {
          type: String
        },

        /**
         * The event that fires from items when they are selected. Selectable
         * will listen for this event from items and update the selection state.
         * Set to empty string to listen to no events.
         */
        activateEvent: {
          type: String,
          attribute: 'activate-event'
        },

        /**
         * This is a CSS selector string.  If this is set, only items that match the
         * CSS selector are selectable.
         */
        selectable: {
          type: String
        },

        /**
         * The class to set on elements when selected.
         */
        selectedClass: {
          type: String,
          attribute: 'selected-class'
        },

        /**
         * The attribute to set on elements when selected.
         */
        selectedAttribute: {
          type: String,
          attribute: 'selected-attribute'
        },

        /**
         * Default fallback if the selection based on selected with
         * `attrForSelected` is not found.
         */
        fallbackSelection: {
          type: String,
          attribute: 'fallback-selection'
        },

        /**
         * The set of excluded elements where the key is the `localName`
         * of the element that will be ignored from the item list.
         *
         * @default {template: 1}
         */
        _excludedLocalNames: {
          type: Object
        }
      }
    }

    constructor() {
      super();
      this.attrForSelected = null;
      this.activateEvent = 'click';
      this.selectedClass = 'cells-selected';
      this.selectedAttribute = null;
      this.fallbackSelection = null;
      this.items = [];
      this._excludedLocalNames = {
        'template': 1
      };
      this._bindFilterItem = this._filterItem.bind(this); // En created
      this._selection = new CellsSelection(this._applySelection.bind(this)); // En created
    }

    updated(changedProps) {
      super.updated(changedProps);
      if (changedProps.has('selected')) {
        this._updateSelected();
        this.dispatchEvent(new CustomEvent('selected-changed', {
          detail: {
            value: this.selected
          }
        }));
      }
      if (changedProps.has('activateEvent')) {
        this._activateEventChanged(this.activateEvent, changedProps.get('activateEvent'));
      }
      if (changedProps.has('attrForSelected')) {
        this._updateAttrForSelected();
      }
      if (changedProps.has('fallbackSelection')) {
        this._checkFallback();
      }
    }

    connectedCallback() {
      super.connectedCallback();

      this._observer = this._observeItems(this);
      this._addListener(this.activateEvent);
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      if (this._observer) {
        this._observer.disconnect();
      }
      this._removeListener(this.activateEvent);
    }

    /**
     * Returns the index of the given item.
     *
     * @method indexOf
     * @param {Object} item
     * @returns Returns the index of the item
     */
    indexOf(item) {
      return this.items ? this.items.indexOf(item) : -1;
    }

    /**
     * Selects the given value.
     *
     * @method select
     * @param {string|number} value the value to select.
     */
    select(value) {
      this.selected = value;
    }

    /**
     * Selects the previous item.
     *
     * @method selectPrevious
     */
    selectPrevious() {
      var length = this.items.length;
      var index = length - 1;
      if (this.selected !== undefined) {
        index = (Number(this._valueToIndex(this.selected)) - 1 + length) % length;
      }
      this.selected = this._indexToValue(index);
    }

    /**
     * Selects the next item.
     *
     * @method selectNext
     */
    selectNext() {
      var index = 0;
      if (this.selected !== undefined) {
        index = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
      }
      this.selected = this._indexToValue(index);
    }

    /**
     * Selects the item at the given index.
     *
     * @method selectIndex
     */
    selectIndex(index) {
      this.select(this._indexToValue(index));
    }

    /**
     * Force a synchronous update of the `items` property.
     *
     * NOTE: Consider listening for the `cells-items-changed` event to respond to
     * updates to the set of selectable items after updates to the DOM list and
     * selection state have been made.
     *
     * WARNING: If you are using this method, you should probably consider an
     * alternate approach. Synchronously querying for items is potentially
     * slow for many use cases. The `items` property will update asynchronously
     * on its own to reflect selectable items in the DOM.
     */
    forceSynchronousItemUpdate() {
      if (this._observer && typeof this._observer.flush === 'function') {
        // NOTE(bicknellr): `dom.flush` above is no longer sufficient to trigger
        // `observeNodes` callbacks. Polymer 2.x returns an object from
        // `observeNodes` with a `flush` that synchronously gives the callback any
        // pending MutationRecords (retrieved with `takeRecords`). Any case where
        // ShadyDOM flushes were expected to synchronously trigger item updates
        // will now require calling `forceSynchronousItemUpdate`.
        this._observer.flush();
      } else {
        this._updateItems();
      }
    }

    _checkFallback() {
      this._updateSelected();
    }

    _addListener(eventName) {
      this.addEventListener(eventName, this._activateHandler);
    }

    _removeListener(eventName) {
      this.removeEventListener(eventName, this._activateHandler);
    }

    _activateEventChanged(eventName, old) {
      this._removeListener(old);
      this._addListener(eventName);
    }

    _updateItems() {
      const p = Element.prototype;
      const matchesSelector = p.matches || p.matchesSelector ||
        p.mozMatchesSelector || p.msMatchesSelector ||
        p.oMatchesSelector || p.webkitMatchesSelector;
      const query = this.selectable || '*';
      var nodes = FlattenedNodesObserver.getFlattenedNodes(this).filter(n => {
        return n.nodeType === Node.ELEMENT_NODE && matchesSelector.call(n, query);
      });
      nodes = Array.prototype.filter.call(nodes, this._bindFilterItem);
      this.items = nodes;
      this.dispatchEvent(new CustomEvent('items-changed', {
        detail: {
          value: this.items
        }
      }));
    }

    _updateAttrForSelected() {
      if (this.selectedItem) {
        this.selected = this._valueForItem(this.selectedItem);
      }
    }

    _updateSelected() {
      this._selectSelected(this.selected);
    }

    _selectSelected(selected) {
      if (!this.items) {
        return;
      }

      var item = this._valueToItem(this.selected);
      if (item) {
        this._selection.select(item);
      } else {
        this._selection.clear();
      }
      // Check for items, since this array is populated only when attached
      // Since Number(0) is falsy, explicitly check for undefined
      if (this.fallbackSelection && this.items.length &&
          (this._selection.get() === undefined)) {
        this.selected = this.fallbackSelection;
      }
    }

    _filterItem(node) {
      return !this._excludedLocalNames[node.localName];
    }

    _valueToItem(value) {
      return (value == null) ? null : this.items[this._valueToIndex(value)];
    }

    _valueToIndex(value) {
      if (this.attrForSelected) {
        for (var i = 0, item; item = this.items[i]; i++) {
          if (this._valueForItem(item) == value) {
            return i;
          }
        }
      } else {
        return Number(value);
      }
    }

    _indexToValue(index) {
      if (this.attrForSelected) {
        var item = this.items[index];
        if (item) {
          return this._valueForItem(item);
        }
      } else {
        return index;
      }
    }

    _valueForItem(item) {
      if (!item) {
        return null;
      }
      if (!this.attrForSelected) {
        var i = this.indexOf(item);
        return i === -1 ? null : i;
      }
      const camelCaseAttr = this.attrForSelected.indexOf('-') < 0 ? this.attrForSelected : this.attrForSelected.replace(/-[a-z]/g, (m) => m[1].toUpperCase());
      var propValue = item[camelCaseAttr];
      return propValue != undefined ? propValue : item.getAttribute(this.attrForSelected);
    }

    _applySelection(item, isSelected) {
      if (this.selectedClass) {
        item.classList.toggle(this.selectedClass, isSelected);
      }
      if (this.selectedAttribute) {
        item.toggleAttribute(this.selectedAttribute, isSelected);
      }
      this._selectionChange();
      const eventName = 'cells-' + (isSelected ? 'select' : 'deselect');
      this.dispatchEvent(new CustomEvent(eventName, {
        bubbles: true,
        composed: true,
        detail: {
          item: item
        }
      }));
    }

    _selectionChange() {
      this.selectedItem = this._selection.get();
      this.dispatchEvent(new CustomEvent('selected-item-changed', {
        detail: {
          value: this.selectedItem
        }
      }));
    }

    // observe items change under the given node.
    _observeItems(node) {
      return new FlattenedNodesObserver(node, function(mutation) {
        this._updateItems();
        this._updateSelected();

        // Let other interested parties know about the change so that
        // we don't have to recreate mutation observers everywhere.
        this.dispatchEvent(new CustomEvent('cells-items-changed', {
          cancelable: false,
          detail: mutation
        }));
      });
    }

    _activateHandler(e) {
      var t = e.target;
      var items = this.items;
      while (t && t != this) {
        var i = items.indexOf(t);
        if (i >= 0) {
          var value = this._indexToValue(i);
          this._itemActivate(value, t, e);
          return;
        }
        t = t.parentNode;
      }
    }

    _itemActivate(value, item, ev) {
      this.dispatchEvent(new CustomEvent('cells-activate', {
        cancelable: true,
        bubbles: true,
        composed: true,
        detail: {
          selected: value,
          item: item
        }
      }));
      this.select(value);
    }

  }
});
