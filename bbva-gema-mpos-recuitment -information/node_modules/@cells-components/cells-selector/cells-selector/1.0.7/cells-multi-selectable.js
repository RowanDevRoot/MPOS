/**
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
import { LitElement, } from 'lit-element';
import { dedupingMixin, } from '@cells-components/cells-lit-helpers/utils/mixin.js';
import { CellsSelectableMixin } from './cells-selectable.js';

/**
 * @mixinFunction CellsMultiSelectableMixin
 */
export const CellsMultiSelectableMixin = dedupingMixin(superClass => {
  return class extends CellsSelectableMixin(superClass) {

    constructor() {
      super();
      this.multi = false;
      this.selectedValues = [];
      this.selectedItems = [];
    }

    static get properties() {
      return {
        /**
         * If true, multiple selections are allowed.
         */
        multi: {
          type: Boolean
        },

        /**
         * Gets or sets the selected elements. This is used instead of `selected`
         * when `multi` is true.
         */
        selectedValues: {
          type: Array,
          attribute: 'selected-values'
        }
      }
    }

    updated(changedProperties) {
      super.updated(changedProperties);
      if (changedProperties.has('multi')) {
        this.multiChanged(this.multi);
      }
      if (changedProperties.has('selectedValues')) {
        this._updateSelected();
        this.dispatchEvent(new CustomEvent('selected-values-changed'), {
          detail: {
            value: this.selectedValues
          }
        });
      }
    }

    /**
     * Selects the given value. If the `multi` property is true, then the selected
     * state of the `value` will be toggled; otherwise the `value` will be
     * selected.
     *
     * @method select
     * @param {string|number} value the value to select.
     */
    select(value) {
      if (this.multi) {
        this._toggleSelected(value);
      } else {
        this.selected = value;
      }
    }

    multiChanged(multi) {
      this._selection.multi = multi;
      this._updateSelected();
    }

    // UNUSED, FOR API COMPATIBILITY
    get _shouldUpdateSelection() {
      return this.selected != null ||
          (this.selectedValues != null && this.selectedValues.length);
    }

    _updateAttrForSelected() {
      if (!this.multi) {
        super._updateAttrForSelected();
      } else if (this.selectedItems && this.selectedItems.length > 0) {
        this.selectedValues =
            this.selectedItems
                .map(
                    function(selectedItem) {
                      return this._indexToValue(this.indexOf(selectedItem));
                    },
                    this)
                .filter(function(unfilteredValue) {
                  return unfilteredValue != null;
                }, this);
      }
    }

    _updateSelected() {
      if (this.multi) {
        this._selectMulti(this.selectedValues);
      } else {
        this._selectSelected(this.selected);
      }
    }

    _selectMulti(values) {
      values = values || [];

      var selectedItems =
          (this._valuesToItems(values) || []).filter(function(item) {
            return item !== null && item !== undefined;
          });

      // clear all but the current selected items
      this._selection.clear(selectedItems);
      // select only those not selected yet
      for (var i = 0; i < selectedItems.length; i++) {
        this._selection.setItemSelected(selectedItems[i], true);
      }

      // Check for items, since this array is populated only when attached
      if (this.fallbackSelection && this._selection.get() && !this._selection.get().length) {
        var fallback = this._valueToItem(this.fallbackSelection);
        if (fallback) {
          this.select(this.fallbackSelection);
        }
      }
    }

    _selectionChange() {
      var s = this._selection.get();
      if (this.multi) {
        this.selectedItems = s;
        this.selectedItem = s.length ? s[0] : null;
      } else {
        if (s !== null && s !== undefined) {
          this.selectedItems = [s];
          this.selectedItem = s;
        } else {
          this.selectedItems = [];
          this.selectedItem = null;
        }
      }
      this.dispatchEvent(new CustomEvent('selected-items-changed', {
        detail: {
          value: this.selectedItems
        }
      }));
      this.dispatchEvent(new CustomEvent('selected-item-changed', {
        detail: {
          value: this.selectedItem
        }
      }));
    }

    _toggleSelected(value) {
      var i = this.selectedValues.indexOf(value);
      var unselected = i < 0;
      if (unselected) {
        this.selectedValues.push(value);
      } else {
        this.selectedValues.splice(i, 1)
      }
      this._updateSelected();
    }

    _valuesToItems(values) {
      return (values == null) ? null : values.map(function(value) {
        return this._valueToItem(value);
      }, this);
    }
  }
});
