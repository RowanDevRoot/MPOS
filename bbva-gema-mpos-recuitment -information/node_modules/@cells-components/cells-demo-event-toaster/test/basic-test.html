<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

  <title>cells-demo-event-toaster test</title>

  <script src="../../../../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../../../node_modules/wct-browser-legacy/browser.js"></script>
</head>

<body>

  <test-fixture id="default">
    <template>
      <cells-demo-event-toaster></cells-demo-event-toaster>
    </template>
  </test-fixture>

  <test-fixture id="multiple">
    <template>
      <cells-demo-event-toaster multiple events='["a", "b"]'></cells-demo-event-toaster>
    </template>
  </test-fixture>

  <test-fixture id="verticalAlign">
    <template>
      <cells-demo-event-toaster vertical-align="top"></cells-demo-event-toaster>
    </template>
  </test-fixture>

  <script type="module">
    import '../cells-demo-event-toaster.js';
    // import { dom, } from '@polymer/polymer/lib/legacy/polymer.dom.js';
    suite('<cells-demo-event-toaster> tag', function() {
      var myEl;

      setup(async () => {
        myEl = fixture('default');
        return await myEl.updateComplete;
      });

      test('sets an event listener to window for each event in events Array property', async () => {
        var listenStub = sinon.spy(window, 'addEventListener');
        myEl.events = ['uno', 'dos', 'tres'];
        await myEl.updateComplete;
        myEl.events.forEach(function(event, index) {
          assert.isTrue(listenStub.getCall(index).args[0] === event, 'event is added to window');
        });
      });

      test('duration property sets duration to toast', async () => {
        myEl.duration = 1000;
        await myEl.updateComplete;
        assert.equal(myEl.shadowRoot.querySelector('#toast').duration, myEl.duration, 'duration property is properly binded');
      });

      test('when an event of events Array is fired, the toast is opened and refit', async () => {
        var toast = myEl.shadowRoot.querySelector('#toast');
        var openToastStub = sinon.stub(toast, 'open');
        var refitToastStub = sinon.stub(toast, 'refit');
        myEl.events = ['uno'];
        await myEl.updateComplete;
        window.dispatchEvent(new CustomEvent('uno'));
        await myEl.updateComplete;
        assert.isTrue(openToastStub.called);
        assert.isTrue(refitToastStub.called);
      });

      test('opened toast is cancelled if a new event is fired while the toast is visible', async () => {
        myEl.events = ['cuatro', 'cinco'];
        var cancelToastStub = sinon.stub(myEl.shadowRoot.querySelector('#toast'), 'cancel');
        await myEl.updateComplete;
        window.dispatchEvent(new CustomEvent('cuatro'));
        await myEl.updateComplete;
        window.dispatchEvent(new CustomEvent('cinco'));
        assert.isTrue(cancelToastStub.called);
      });

      test('toast is closed after clicking on it', () => {
        var closeToastStub = sinon.stub(myEl.shadowRoot.querySelector('#toast'), 'close');
        myEl.shadowRoot.querySelector('#toast').click();
        assert.isTrue(closeToastStub.called);
      });

      test('toast text contains the event.type', async () => {
        myEl.events = ['uno'];
        await myEl.updateComplete;
        await myEl.updateComplete;
        var toastText = myEl.shadowRoot.querySelector('.highlight');
        window.dispatchEvent(new CustomEvent('uno'));
        assert.equal(toastText.innerText, myEl.events[0]);
      });

      test('toast text contains the event payload if the event has detail', async () => {
        myEl.events = ['uno'];
        await myEl.updateComplete;
        window.dispatchEvent(new CustomEvent('uno', { detail: 'something' }));
        await myEl.updateComplete;
        var toastTextPayload = myEl.shadowRoot.querySelectorAll('.highlight')[1];
        assert.equal(toastTextPayload.innerText, '"something"');
      });

      test('toast text does not contain the event payload if the event detail is empty', async () => {
        myEl.events = ['uno'];
        await myEl.updateComplete;
        window.dispatchEvent(new CustomEvent('uno', { detail: {} }));
        await myEl.updateComplete;
        var toastTextPayload = myEl.shadowRoot.querySelectorAll('.highlight')[1];
        assert.equal(toastTextPayload, undefined, 'payload text is not rendered');
      });

      test('toast text contains the nodeName if the event detail is a reference to a HTMLElement', async () => {
        myEl.events = ['uno'];
        await myEl.updateComplete;
        var htmlNode = document.createElement('section');
        window.dispatchEvent(new CustomEvent('uno', { detail: htmlNode }));
        await myEl.updateComplete;
        var toastTextPayload = myEl.shadowRoot.querySelectorAll('.highlight')[1];
        assert.equal(toastTextPayload.innerText, '[HTMLElement] ' + htmlNode.nodeName + ' (more info in console)');
      });

      test('console.info() is called if the event detail is a reference to a HTMLElement', async () => {
        myEl.events = ['uno'];
        await myEl.updateComplete;
        var consoleInfoStub = sinon.stub(window.console, 'info');
        var htmlNode = document.createElement('section');
        window.dispatchEvent(new CustomEvent('uno', { detail: htmlNode }));
        await myEl.updateComplete;
          assert.equal(consoleInfoStub.getCall(0).args[0], '[cells-demo-event-toaster]: Payload of uno', 'console.info is called and contains event.type and event.detail');
      });
    });

    suite('<cells-demo-event-toaster multiple>', function() {
      var el;

      setup(async () => {
        el = fixture('multiple');
        el.duration = 10;
        return await el.updateComplete;
      });

      test('toast duration is set to 0 (infinite)', () => {
        assert.equal(el.shadowRoot.querySelector('#toast').duration, 0);
      });

      test('when window fires multiple listened events, multiple toasts are shown', async () => {
        window.dispatchEvent(new CustomEvent('a'));
        window.dispatchEvent(new CustomEvent('b'));

        await el.updateComplete;

        var innerToasts = el.shadowRoot.querySelectorAll('.inner-toast');
        [].forEach.call(innerToasts, function(toast) {
          // selecting [visible] does not work
          assert.isAbove(window.getComputedStyle(toast).order, 0, 'order has been set (is above 0), so toast has been shown');
        });
      });

      test('internal toast is hidden after a timeout equal to duration property', async () => {
        let clock = sinon.useFakeTimers();
        window.dispatchEvent(new CustomEvent('a'));
        await el.updateComplete;
        clock.tick(20);
        await el.updateComplete;
        var innerToast = el.shadowRoot.querySelectorAll('.inner-toast');
        assert.isFalse(innerToast[0].hasAttribute('visible'));
        clock.restore();
      });
    });

    suite('custom vertical align', function() {
      var el;

      setup(async () => {
        el = fixture('verticalAlign');
        return await el.updateComplete;
      });

      test('setting "vertical-align" sets "vertical-align" on <paper-toast>', function() {
        var paperToast = el.shadowRoot.querySelector('#toast');
        assert.equal(paperToast.verticalAlign, el.verticalAlign, 'verticalAlign property is properly binded to <paper-toast>');
      });
    });
  </script>
</body>

</html>
