/* eslint-disable new-cap */
import { LitElement, html, } from 'lit-element';
import { getComponentSharedStyles, } from '@cells-components/cells-lit-helpers';
import { ifDefined } from 'lit-html/directives/if-defined.js';
import { CellsFocusVisibleMixin } from '@cells-components/cells-focus-visible-mixin';
import { add as GesturesAddListener } from '@cells-components/cells-lit-helpers/utils/gestures.js';
import styles from './cells-button-styles.js';
/**
`CellsButton` provides a base class as well as a `<cells-button>` custom element with button functionality as close as possible to native buttons. It provides an easier and convenient way to build buttons with encapsulated HTML & custom styles. As it almost does not provide any styles, it's specially aimed to be extended.

As native buttons, it can communicate with forms in the same document using standard form attributes, as well as use roles & aria attributes (for example, aria-expanded). It can receive any valid 'type' for buttons ('submit', 'button' or 'reset'), a 'disabled' state, and receive an 'autofocus' attribute to get focus when component is attached to the document.

`CellsButton` is heavily based on [weightless.dev button](https://weightless.dev/elements/button) for the form communication, and on [Vaadin Button](https://vaadin.com/components/vaadin-button) for the active state management.

When extending from `CellsButton`, just make sure to:
- Call `CellsButton` styles using `super.styles`
- Add a `<slot>` in render
- Use `this._button` getter in render to enable communication with native forms.

**Example**
```js
// Extending CellsButton to create a CustomButton element
class CustomButton extends CellsButton {
  static get properties() {
    return {
      // Additional properties here
    };
  }

  static get styles() { // be sure to get styles from upper class using super
    return [
      super.styles,
      styles,
      getComponentSharedStyles('custom-button-shared-styles')
    ];
  }

  render() { // include any HTML you need; for example, icons
    return html`
      <slot></slot>
      ${this._button}
    `;
  }
}
customElements.define('custom-button', CustomButton)
```

```html
<custom-button>This is a button</custom-button>
<custom-button disabled>This is a disabled button</custom-button>
<custom-button @click="${this._onClick}">This is a button inside another LitElement with click listener</custom-button>
<custom-button role="switch" aria-expanded="true">Button with role and arias</custom-button>
```

## FocusVisible mixin

`CellsButton` uses `FocusVisible mixin` from `@cells-components`. This means you can use the 'focus-visible' attribute on your component to manage ':focus' styles based on user navigation interface (keyboard/pointer).

```css
:host([focus-visible]) {
  ...your focus styles...
}
```

## Form communication

To be able to communicate with **forms in the same document**, a component which extends from `CellsButton` must implement `_button` getter in its render method.
```js
  render() {
    return html`
      <slot></slot>
      ${this._button}
    `;
  }
```

This way, the component will be able to use the same attributes native buttons have to customize interaction with forms: 'name', 'value', 'form', 'formaction', 'formenctype', 'formmethod', 'formnovalidate' and 'formtarget'.

```html
<form action="formaction" method="get" target="_self">
  <custom-button value="buttonValue" name="customButtonName" formaction="differentaction" formmethod="post" formtarget="_blank">Submit button for form</custom-button>
</form>
```

## Caveats

### Click listeners previous to button definition

Setting a `CellsButton` as 'disabled' will prevent clicks on the button. This is true for mouse clicks, keyboard clicks, programmatic clicks or screen reader clicks. However, a disabled `CellsButton` won't prevent click listeners added **previously** to the customElement definition when the click is done programatically or through a screen reader.

### 'active' state

You can use the `:active` CSS pseudo-class to define styles for the button when it's being activated by the user using the mouse. However, this won't work when button is activated using the keyboard. `CellsButton` provides an `active` attribute which gets triggered on keydown and keyup with Spacebar/Enter, as well as with down and up mouse actions (touch or pointer).

```css
:host([active]) {
  ... Active styles ...
}
```

## Styling
The following custom properties are available for styling:

### Custom properties

| Selector          | CSS Property | CSS Variable                  | Theme Variable | Foundations/Fallback |
| ----------------- | ------------ | ----------------------------- | -------------- | -------------------- |
| :host([disabled]) | color        | --cells-button-disabled-color |                | rgba(0, 0, 0, 0.247) |
| :host             | color        | --cells-button-color          |                | rgba(0, 0, 0, 0.847) |
| :host             | border-color | --cells-button-border-color   |                | #d8d8d8              |

> Styling documentation generated by Cells CLI

* @customElement
* @demo demo/index.html
* @extends {LitElement}
* @appliesMixin { CellsFocusVisibleMixin }
*/
export class CellsButton extends CellsFocusVisibleMixin(LitElement) {
  static get is() {
    return 'cells-button';
  }

  static get properties() {
    return {
      /**
       * Type for the button, related to forms. Available types are 'button', 'submit' and 'reset'
       */
      type: {
        type: String
      },
      /**
       * Disabled state of button
       */
      disabled: {
        type: Boolean,
        reflect: true
      },
      /**
       * Button value related to forms
       */
      value: {
        type: String,
        reflect: true
      },
      /**
       * Name of button related to forms
       */
      name: {
        type: String,
        reflect: true
      },
      /**
       * Associated form for button
       */
      form: {
        type: String
      },
      /**
       * Associated formaction for button
       */
      formAction: {
        type: String,
        reflect: true
      },
      /**
       * Associated formenctype for button
       */
      formEnctype: {
        type: String,
        reflect: true
      },
      /**
       * Associated formmethod for button
       */
      formMethod: {
        type: String,
        reflect: true
      },
      /**
       * Associated formnovalidate for button
       */
      formNoValidate: {
        type: Boolean,
        reflect: true
      },
      /**
       * Associated formtarget for button
       */
      formTarget: {
        type: String,
        reflect: true
      },
      _formElementId: {
        type: String
      }
    };
  }

  constructor() {
    super();
    this.type = 'submit';
    this._active = false;
    this._formElementId = this.uniqueID();
  }

  /**
   * Returns unique ID string
   * @param  {Number} length Length of ID
   * @return {String}        String of random number
   */
  uniqueID(length = 10) {
    return `_${Math.random().toString(36).substr(2, length)}`;
  }

  connectedCallback() {
    super.connectedCallback();
    this._setInitialAttribute('role', 'button');
    if (this.disabled) {
      this._disableButton();
    } else {
      this._setInitialAttribute('tabindex', '0');
      this.setAttribute('aria-disabled', 'false');
    }
    this.onClick = this.onClick.bind(this);
    this.onKeyUp = this.onKeyUp.bind(this);
    this.onKeyDown = this.onKeyDown.bind(this);
    this.addEventListener('click', this.onClick);
    this.addEventListener('keyup', this.onKeyUp);
    this.addEventListener('keydown', this.onKeyDown);
    GesturesAddListener(this, 'down', () => !this.disabled && (this.active = true));
    GesturesAddListener(this, 'up', () => this.active = false);
    this.addEventListener('blur', () => this.active = false);
    if (this.hasAttribute('autofocus')) {
      this.focus();
    }
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeEventListener('click', this.onClick);
    this.removeEventListener('keydown', this.onKeyDown);
    if (this.active) {
      this.active = false;
    }
  }

  firstUpdated(changedProps) {
    super.firstUpdated(changedProps);
    this._formElement = this.shadowRoot.querySelector(`#${this._formElementId}`);
    if (this._formElement) {
      this.appendChild(this._formElement);
    }
  }

  updated(changedProps) {
    super.updated(changedProps);
    if (changedProps.has('disabled')) {
      if (this.disabled) {
        this._disableButton();
      } else {
        this._enableButton();
      }
    }
  }

  /**
   * Active state of button
   * @return {Boolean} Active state of button
   */
  get active() {
    return this._active;
  }

  /**
   * Sets active state for button
   * @param  {Boolean} value Active state for button
   */
  set active(value) {
    if (value !== this._active) {
      this._active = value;
      if (value) {
        this.setAttribute('active', '');
      } else {
        this.removeAttribute('active');
      }
    }
  }

  static get styles() {
    return [
      styles,
      getComponentSharedStyles('cells-button-shared-styles')
    ];
  }

  render() {
    return html`
      <slot></slot>
      ${this._button}
    `;
  }

  /**
   * Native button to be moved to light DOM for communication with native forms
   * @return {TemplateResult} HTML of native button
   */
  get _button() {
    return html`
      <button
        style="display: none;"
        id="${this._formElementId}"
        aria-hidden="true"
        tabindex="-1"
        type="${this.type}"
        ?disabled="${this.disabled}"
        name="${ifDefined(this.name)}"
        value="${ifDefined(this.value)}"
        form="${ifDefined(this.form)}"
        formaction="${ifDefined(this.formAction)}"
        formenctype="${ifDefined(this.formEnctype)}"
        formmethod="${ifDefined(this.formMethod)}"
        ?formNoValidate="${ifDefined(this.formNoValidate)}"
        formtarget="${ifDefined(this.formTarget)}">
      </button>
    `;
  }

  _setInitialAttribute(attr, value) {
    if (!this.hasAttribute(attr)) {
      this.setAttribute(attr, value);
    }
  }

  _disableButton() {
    this.setAttribute('aria-disabled', 'true');
    this.setAttribute('tabindex', '-1');
  }

  _enableButton() {
    this.setAttribute('aria-disabled', 'false');
    this.setAttribute('tabindex', '0');
  }

  /**
   * Fires click on native button for forms if button is not disabled
   * @param  {event} e Original click event
   */
  onClick(e) {
    if (this.disabled) {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      return;
    }
    if (!e.defaultPrevented && this._formElement && e.target !== this._formElement) {
      this._formElement.dispatchEvent(new MouseEvent('click', {
        relatedTarget: this,
        composed: true
      }));
    }
  }

  /**
   * Fires click on element on spacebar or Enter keyup if button is currently being pressed
   * @param  {event} e Original keyup event
   */
  onKeyUp(e) {
    if ((e.keyCode === 13 || e.keyCode === 32) && this.active) {
      this.active = false;
      this.dispatchEvent(new MouseEvent('click', {
        bubbles: true,
        composed: true,
        cancelable: true,
      }));
      e.preventDefault();
      e.stopPropagation();
    }
  }

  /**
   * Sets active state on element on spacebar or Enter keydown
   * @param  {event} e Original keyup event
   */
  onKeyDown(e) {
    if (e.keyCode === 13 || e.keyCode === 32) {
      this.active = true;
      e.preventDefault();
      e.stopPropagation();
    }
  }
}

customElements.define(CellsButton.is, CellsButton);
