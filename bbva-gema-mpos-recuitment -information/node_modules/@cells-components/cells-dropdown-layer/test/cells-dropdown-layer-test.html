<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>cells-dropdown-layer test</title>
  <script src="../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../node_modules/mocha/mocha.js"></script>
  <script src="../node_modules/wct-mocha/wct-mocha.js"></script>
  <script src="../node_modules/chai/chai.js"></script>
  <script src="../node_modules/sinon/pkg/sinon.js"></script>
  <script src="../node_modules/@polymer/test-fixture/test-fixture.js"></script>
  <script src="../node_modules/sinon-chai/lib/sinon-chai.js"></script>
</head>

<body>

  <test-fixture id="el">
    <template>
      <cells-dropdown-layer label="Lorem"></cells-dropdown-layer>
    </template>
  </test-fixture>

  <script type="module">
    import './test.js';
    suite('<cells-dropdown-menu> tag', function() {
      let el;

      suite('in general', () => {
        setup(async () => {
          el = fixture('el');
          await el.updateComplete;
        });

        teardown(() => {
          el.close();
        });

        test('click on control opens layer', () => {
          assert.isFalse(el.opened);
          const control = el.shadowRoot.querySelector('.control-text');
          control.click();
          assert.isTrue(el.opened);
        });

        test('click on control closes open layer', async () => {
          el.opened = true;
          await el.updateComplete;
          const control = el.shadowRoot.querySelector('.control-text');
          control.click();
          assert.isFalse(el.opened);
        });

        test('click on disabled control does not open the layer', async () => {
          el.disabled = true;
          await el.updateComplete;
          assert.isFalse(el.opened);
          const control = el.shadowRoot.querySelector('.control-text');
          control.click();
          assert.isFalse(el.opened);
        });

        test('click event on opener when disabled does not open the layer', async () => {
          el.disabled = true;
          await el.updateComplete;
          assert.isFalse(el.opened);
          const opener = el.shadowRoot.querySelector('.opener');
          opener.dispatchEvent(new CustomEvent('click'));
          assert.isFalse(el.opened);
        });

        test('pressing Esc key with dropdown open closes the dropdown', async () => {
          el.opened = true;
          await el.updateComplete;
          const event = new CustomEvent('keydown');
          event.keyCode = 27;
          el.dispatchEvent(event);
          assert.isFalse(el.opened);
        });

        test('pressing a different key from Esc with dropdown open does not close the dropdown', async () => {
          el.opened = true;
          await el.updateComplete;
          const event = new CustomEvent('keydown');
          event.keyCode = 28;
          el.dispatchEvent(event);
          assert.isTrue(el.opened);
        });

        test('passing error string set has-error attribute', async () => {
          assert.isFalse(el.hasAttribute('has-error'));
          el.error = 'Test';
          await el.updateComplete;
          assert.isTrue(el.hasAttribute('has-error'));
        });

        test('passing empty error string does not set has-error attribute', async () => {
          assert.isFalse(el.hasAttribute('has-error'));
          el.error = '';
          await el.updateComplete;
          assert.isFalse(el.hasAttribute('has-error'));
        });

        test('clicking outside layer when it is open does close it', async () => {
          el.opened = true;
          await el.updateComplete;
          document.body.click();
          assert.isFalse(el.opened);
        });

        test('clicking directly on layer div does close it', async () => {
          el.opened = true;
          await el.updateComplete;
          const layer = el.shadowRoot.querySelector('.layer');
          layer.dispatchEvent(new CustomEvent('click', {
            bubbles: true,
            composed: true
          }));
          assert.isFalse(el.opened);
        });

        test('clicking on layer content does not close it', async () => {
          el.opened = true;
          await el.updateComplete;
          const layerContent = el.shadowRoot.querySelector('.layer-content');
          layerContent.click();
          assert.isTrue(el.opened);
        });

        test('layer min width is equal to control width', async () => {
          const clock = sinon.useFakeTimers();
          el.label = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit';
          await el.updateComplete;

          el.opened = true;
          await el.updateComplete;

          clock.tick(100);

          const control = el.offsetWidth;
          const layer = el.shadowRoot.querySelector('.layer-content').offsetWidth;
          assert.equal(layer, control);

          clock.restore();
        });

        test('using controlAsMinWidthOff property allows layer to be smaller than control', async () => {
          el.label = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit';
          el.controlAsMinWidthOff = true;
          await el.updateComplete;
          const control = el.offsetWidth;
          el.opened = true;
          await el.updateComplete;
          const layer = el.shadowRoot.querySelector('.layer-content').offsetWidth;
          assert.isBelow(layer, control);
        });

        test('open method opens the layer', async () => {
          assert.isFalse(el.opened);
          el.open();
          await el.updateComplete;
          assert.isTrue(el.opened);
        });

        test('close method does not modify an already closed layer', async () => {
          assert.isFalse(el.opened);
          el.close();
          await el.updateComplete;
          assert.isFalse(el.opened);
        });

        test('open method does not modify an already opened layer', async () => {
          el.opened = true;
          el.open();
          await el.updateComplete;
          assert.isTrue(el.opened);
        });

        test('opening-x left-to-right assigns correct direction class to layer', async () => {
          el.openingX = 'left-to-right';
          el.opened = true;
          await el.updateComplete;
          const layer = el.shadowRoot.querySelector('.layer');
          assert.isTrue(layer.classList.contains('left'));
        });

        test('opening-x right-to-left assigns correct direction class to layer', async () => {
          el.openingX = 'right-to-left';
          el.opened = true;
          await el.updateComplete;
          const layer = el.shadowRoot.querySelector('.layer');
          assert.isTrue(layer.classList.contains('right'));
        });

        test('opening-x centered assigns correct direction class to layer', async () => {
          el.openingX = 'centered';
          el.opened = true;
          await el.updateComplete;
          const layer = el.shadowRoot.querySelector('.layer');
          assert.isTrue(layer.classList.contains('centered'));
        });

        test('not enough space to the right defaults layer to right-to-left opening', async () => {
          el.style = 'float: right';
          el.opened = true;
          await el.updateComplete;
          const layer = el.shadowRoot.querySelector('.layer');
          assert.isTrue(layer.classList.contains('right'));
        });

        test('opening-y top-to-bottom assigns correct direction class to layer', async () => {
          el.openingY = 'top-to-bottom';
          el.opened = true;
          await el.updateComplete;
          const layer = el.shadowRoot.querySelector('.layer');
          assert.isTrue(layer.classList.contains('top'));
        });

        test('opening-y bottom-to-top assigns correct direction class to layer', async () => {
          el.openingY = 'bottom-to-top';
          el.opened = true;
          await el.updateComplete;
          const layer = el.shadowRoot.querySelector('.layer');
          assert.isTrue(layer.classList.contains('bottom'));
        });

        test('not enough space to the bottom defaults layer to bottom-to-top opening', async () => {
          el.style = 'position: fixed; bottom: 0;';
          el.opened = true;
          await el.updateComplete;
          const layer = el.shadowRoot.querySelector('.layer');
          assert.isTrue(layer.classList.contains('bottom'));
        });

        test('transitionend on layer set layer width', async () => {
          const layer = el.shadowRoot.querySelector('.layer');
          assert.equal(layer.style.width, '');
          el.opened = true;
          await el.updateComplete;
          layer.dispatchEvent(new CustomEvent('transitionend'));
          assert.notEqual(layer.style.width, '');
        });

        test('transitionend on closed layer clears direction classes from layer div', async () => {
          const layer = el.shadowRoot.querySelector('.layer');
          el.opened = true;
          await el.updateComplete;
          assert.isTrue(layer.classList.contains('left'));

          el.opened = false;
          layer.dispatchEvent(new CustomEvent('transitionend'));
          await el.updateComplete;
          assert.isFalse(layer.classList.contains('left'));
        });

        test('focus method set focus on control button', async () => {
          const innerButton = el.shadowRoot.querySelector('.control-text');
          el.focus();
          await el.updateComplete;
          assert.equal(el.shadowRoot.activeElement, innerButton);
        });
      })
    });
  </script>
</body>

</html>
