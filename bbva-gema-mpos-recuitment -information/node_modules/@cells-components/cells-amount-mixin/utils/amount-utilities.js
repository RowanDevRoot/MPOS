import { separators, groupChars, currenciesMap, minusAfterSymbolLocalCurrencies, currenciesWithoutDecimals, rightAlignedCurrencies, abbreviations } from './amount-currencies.js';
/**
 * Functions for getting formating info and parts from currencies amounts based on language, currencyCode, localCurrency...
 */

/**
 * Get group hundreds according to language
 * @param  { String } language Language to check in groupChars object
 * @return { String }          Thousans separator character
 */
export function getGroupChars(language) {
  language = language.toLowerCase();
  return groupChars[language] ||
    groupChars[language.substring(0, language.indexOf('-'))];
}

/**
 * Get hundreds separator according to language
 * @param  { String } language Language to check in separators object
 * @return { String }          Fractional separator character
 */
export function getSeparator(language) {
  language = language.toLowerCase();
  return separators[language] ||
    separators[language.substring(0, language.indexOf('-'))];
}

/**
 * Input String prepared for [ISO 4217 Currency Codes]
 * @param  { String } localCurrency Local currency code to use
 * @param  { String } currencyCode  Currency Code
 * @return { String }               Currency symbol
 */
export function getCurrencyAsSymbol(localCurrency, currencyCode) {
  return (currenciesMap[localCurrency] &&
    currenciesMap[localCurrency][currencyCode]) ||
    (currenciesMap.default &&
      currenciesMap.default[currencyCode]) ||
    currencyCode;
}

/**
 * Checks if currency should have decimal part based on currencyCode
 * @param  { String }  currencyCode Currency code
 * @return { Boolean }              Returns true if currency can have decimals
 */
export function hasDecimalPart(currencyCode) {
  return currenciesWithoutDecimals.indexOf(currencyCode) === -1;
}

/**
 * Checks if currency symbol is right aligned based on currencyCode
 * @param  { String }  currencyCode Currency code
 * @return { Boolean }              Returns true if currency symbol is right aligned
 */
export function isRightAligned(currencyCode) {
  return rightAlignedCurrencies.indexOf(currencyCode) !== -1;
}

/**
 * Checks if negative character goes after currency symbol based on local currency code
 * @param  { String }  localCurrency Local currency code
 * @return { Boolean }               Returns true if negative character goes after currency symbol
 */
export function hasMinusAfterSymbol(localCurrency) {
  return minusAfterSymbolLocalCurrencies.indexOf(localCurrency) !== -1;
}

/**
 * Returns provided amount as absolute
 * @param  { Number } amount Amount
 * @return { Number }        Amount as absolute
 */
export function getAbsAmount(amount) {
  return Math.abs(amount || 0);
}

/**
 * Returns amount without fractional part
 * @param  { Number } amount Amount
 * @return { Number }        Amount without fractional part
 */
export function getIntegerAmount(amount) {
  return Math.floor(amount);
}

/**
 * Returns absolute amount without fractional part
 * @param  { Number } amount Amount
 * @return { Number }        Absolute amount without fractional part
 */
export function getIntegerAbsAmount(amount) {
  return getIntegerAmount(getAbsAmount(amount));
}

/**
 * Returns grouped integer
 * @param  { Number } amount    Amount
 * @param  { String } groupChar Group char
 * @return { Number }           Grouped amount
 */
export function getGroupedIntegerString(amount, groupChar) {
  return amount.toString().replace(/(\d)(?=(\d{3})+$)/g, `$1${groupChar}`);
}

/**
 * Returns grouped absolute integer without fractional part
 * @param  { Number } amount    Amount
 * @param  { String } groupChar Group char
 * @return { Number }           Grouped absolute amount without fractional part
 */
export function getGroupedIntegerAbsString(amount, groupChar) {
  return getGroupedIntegerString(getIntegerAbsAmount(amount), groupChar);
}

/**
 * Returns fractional part of amount as integer
 * @param  { Number } amount Positive amount
 * @return { Number }        Fractional part of positive amount as integer
 */
export function getFractionalAmount(amount) {
  const str = amount.toString().split('.')[1] || '';
  return Number(str / 10**str.length);
}

/**
 * Returns number from currency string
 * @param  { String } amount String amount
 * @param  { String } groupChar Group separator
 * @param  { String } decimalChar Decimal separator
 * @return { Number }        Amount as number
 */
export function amountStringToNumber(amount, groupChar, decimalChar) {
  return Number(
    amount
      .replace(new RegExp(`\\${groupChar}`, 'g'), '')
      .replace(new RegExp(`\\${decimalChar}`), '.'),
  );
}

function _getFractionalPart(absAbbrAmount, decimalDigits, trailingZeroDecimalsHidden) {
  let fractional =
  parseFloat(getFractionalAmount(absAbbrAmount).toFixed(decimalDigits))
    .toString()
    .split('.')[1] || '';
  if (trailingZeroDecimalsHidden) {
    return fractional;
  }
  if (fractional.length < decimalDigits) {
    fractional = `${fractional}${new Array(decimalDigits + 1).join('0')}`;
  }
  return fractional.slice(0, decimalDigits);
}

/**
 * Returns amount transformed format configuration
 * @param  { Object } options Object with amount options
 * @param  { String } options.currencyCode Currency Code for amount
 * @param  { String } options.localCurrency Local Currency for amount
 * @param  { String } options.language Language for amount
 * @param  { String } options.minusSymbol Minus symbol to use if amount is negative
 * @param  { Number } options.abbr Amount of digits to abbreviate formatted amount
 * @param  { Object } options.abbreviations Valid abbr values with matching string. Default are 1, 2, 3, 6 and 9
 * @param  { Number } options.decimalDigits Decimal digits to show
 * @param  { Boolean } options.decimalsHidden If true, decimals are hidden
 * @param  { Boolean } options.zeroDecimalsHidden If true, decimals are hidden if equal to 0
 * @param  { Boolean } options.trailingZeroDecimalsHidden Trailing zeroes in decimal part are hidden
 * @param  { Boolean } options.showCurrencyCode If true, currency code will be shown instead of symbol
 * @return { Object }        Object with processed formatting options: negative, minusAfterSymbol, currencySymbol, currencyCode, alignRight, showCurrencyCode, isValidAmount, integer, hideDecimals, fractional, separator, abbreviation
 */
export function getAmountFormatConfig(options) {
  const amount = Number(options.amount);
  const groupChar = getGroupChars(options.language);
  let formattedAmount = getAbsAmount(amount);
  const safeAbbrValue = options.abbr % 1 !== 0 ? 0 : options.abbr;
  const absAbbrAmount = options.abbr ? formattedAmount /= 10 ** safeAbbrValue : formattedAmount;
  const fractionalOverflow = parseInt(
    getFractionalAmount(absAbbrAmount).toFixed(options.decimalDigits),
    10,
  );
  const fractional = _getFractionalPart(absAbbrAmount, options.decimalDigits, options.trailingZeroDecimalsHidden);
  const abbreviation = safeAbbrValue !== 0 && options.abbreviations[safeAbbrValue] ? options.abbreviations[safeAbbrValue] : '';

  return {
    negative: amount < 0,
    minusAfterSymbol: hasMinusAfterSymbol(options.localCurrency),
    currencySymbol: getCurrencyAsSymbol(options.localCurrency, options.currencyCode),
    currencyCode: options.currencyCode,
    alignRight: isRightAligned(options.currencyCode),
    showCurrencyCode: options.showCurrencyCode,
    isValidAmount: Number.isFinite(amount),
    integer: getGroupedIntegerAbsString(absAbbrAmount + fractionalOverflow, groupChar),
    hideDecimals: options.decimalsHidden || !hasDecimalPart(options.currencyCode)
    || (options.zeroDecimalsHidden ? !Number(fractional) : false),
    fractional: fractional,
    separator: getSeparator(options.language),
    abbreviation: abbreviation,
    minusSymbol: options.minusSymbol
  };
}

/**
 * Returns formatted amount
 * @param  { Object } config Object with amount format config
 * @param  { Boolean } config.negative If true, amount is negative
 * @param  { String } config.minusSymbol Minus symbol to show if amount is negative
 * @param  { Boolean } config.minusAfterSymbol If true, minus symbol goes after currency symbol
 * @param  { String } config.currencySymbol Currency symbol to show
 * @param  { String } config.currencyCode Currency code to show if showCurrencyCode is true
 * @param  { Boolean } config.alignRight If true, currency is right aligned
 * @param  { Boolean } config.showCurrencyCode If true, currency code is used instead of currency symbol
 * @param  { Boolean } config.isValidAmount If true, amount is valid
 * @param  { String } config.integer Grouped & abbreviated amount integer to show
 * @param  { Boolean } config.hideDecimals If true, fractional part is hidden
 * @param  { String } config.fractional Fractional part of amount
 * @param  { String } config.separator Fractional separator character to use
 * @param  { String } config.abbreviation Abbreviation string to show after amount
 * @return { String }        Amount formatted according to config
 */
export function getAmountFormattedString(config) {
  let strAmount = '';

  if (config.negative && !config.minusAfterSymbol) {
    strAmount = config.minusSymbol;
  }
  if (config.currencySymbol && !config.alignRight && !config.showCurrencyCode) {
    strAmount += config.currencySymbol;
  }
  if (config.negative && config.minusAfterSymbol) {
    strAmount += config.minusSymbol;
  }
  if (config.isValidAmount) {
    strAmount += config.integer;
  }
  console.log(config.hideDecimals);
  if (!config.hideDecimals && config.fractional) {
    strAmount = strAmount + config.separator + config.fractional;
  }
  if (config.abbreviation) {
    strAmount = `${strAmount} ${config.abbreviation}`;
  }
  if (config.currencySymbol && config.alignRight && !config.showCurrencyCode) {
    strAmount = `${strAmount} ${config.currencySymbol}`;
  }
  if (config.showCurrencyCode) {
    strAmount = `${strAmount} ${config.currencyCode}`;
  }
  return strAmount;
}

/**
 * Transforms user options and returns formatted amount
 * @param  { Number } amount Amount to format
 * @param  { Object } options Object with amount options
 * @param  { String } options.currencyCode Currency Code for amount
 * @param  { String } options.localCurrency Local Currency for amount
 * @param  { String } options.language Language for amount
 * @param  { String } options.minusSymbol Minus symbol to show if amount is negative
 * @param  { Number } options.abbr Amount of digits to abbreviate formatted amount
 * @param  { Object } options.abbreviations Valid abbr values with matching string. Default are 1, 2, 3, 6 and 9
 * @param  { Number } options.decimalDigits Decimal digits to show
 * @param  { Boolean } options.decimalsHidden If true, decimals are hidden
 * @param  { Boolean } options.zeroDecimalsHidden If true, decimals are hidden if equal to 0
 * @param  { Boolean } options.trailingZeroDecimalsHidden Trailing zeroes in decimal part are hidden
 * @param  { Boolean } options.showCurrencyCode If true, currency code will be shown instead of symbol
 * @return { String }        Amount formatted according to options
 */
export function formatAmount(amount, options = {}) {
  const config = getAmountFormatConfig({
    amount: amount || 0,
    currencyCode: options.currencyCode || 'EUR',
    localCurrency: options.localCurrency || 'EUR',
    language: options.language || 'es',
    minusSymbol: options.minusSymbol || '-',
    abbr: options.abbr || options.scale,
    abbreviations: options.abbreviations || abbreviations,
    decimalDigits: Number.isFinite(options.decimalDigits) ? options.decimalDigits : 2,
    decimalsHidden: options.decimalsHidden,
    zeroDecimalsHidden: options.zeroDecimalsHidden,
    trailingZeroDecimalsHidden: options.trailingZeroDecimalsHidden,
    showCurrencyCode: options.showCurrencyCode
  });

  return getAmountFormattedString(config);
}
