import { LitElement, } from 'lit-element';
import { CellsIronMeta, } from '@cells-components/cells-iron-meta/cells-iron-meta.js';
/**

This component ...

Example:

```html
<html>
  <head>
    <script type="module">
      import '@cells-components/cells-iconset-svg/cells-iconset-svg.js';
      import '@cells-components/cells-icon/cells-icon.js';
    </script>
  </head>
  <body>
    <cells-iconset-svg name="inline" size="24">
      <svg>
        <defs>
          <g id="shape">
            <rect x="12" y="0" width="12" height="24"></rect>
            <circle cx="12" cy="12" r="12"></circle>
          </g>
        </defs>
      </svg>
    </cells-iconset-svg>

    <cells-icon icon="inline:shape" role="img" aria-label="A shape"></cells-icon>
  </body>
</html>
```
* @customElement
* @polymer
* @demo demo/index.html
* @extends {LitElement}
* @hero cells-iconset-svg.png
*/
class CellsIconsetSvg extends LitElement {
  static get is() {
    return 'cells-iconset-svg';
  }
  static get properties() {
    return {
      /**
       * Name of the iconset.
       */
      name: { type: String, },

      /**
       * Size for each icon in the iconset. If defined, it will override width and height
       */
      size: { type: Number, },

      /**
       * Width for icons
       */
      width: { type: Number },

      /**
       * Height for icons
       */
      height: { type: Number },

      /**
       * If true, icons can be mirrored when decorated with a 'mirror-in-rtl' attribute
       */
      rtlMirroring: { type: Boolean, },

      /**
       * If true, RTL will be based on the dir attribute of body or html elements
       */
      useGlobalRtlAttribute: { type: Boolean, },

      /**
       * If true, icons will have visible overflow; useful for SVG shadows that overflow the icon viewbox
       */
      overflow: { type: Boolean, },
    };
  }

  constructor() {
    super();
    this.width = 24;
    this.height = 24;
    this.rtlMirroring = false;
    this.useGlobalRtlAttribute = false;
    this.overflow = false;
    this._meta = new CellsIronMeta({
      type: 'iconset',
    });
  }

  /**
   * Width to be used for SVG icons
   */
  get iconWidth() {
    return this.size || this.width;
  }

  /**
   * Height to be used for SVG icons
   */
  get iconHeight() {
    return this.size || this.height;
  }

  updated(changedProps) {
    if (changedProps.has('name')) {
      this._nameChanged();
    }
  }

  connectedCallback() {
    super.connectedCallback();
    this.style.display = 'none';
  }

  /**
   * Construct an array of all icon names in this iconset.
   */
  getIconNames() {
    this._icons = this._createIconMap();
    return Object.keys(this._icons).map(function(n) {
      return this.name + ':' + n;
    }, this);
  }

  /**
   * Applies an icon to the given element.
   */
  applyIcon(element, iconName) {
    this.removeIcon(element);
    var svg = this._cloneIcon(
      iconName, this.rtlMirroring && this._targetIsRTL(element));
    if (svg) {
      var pde = element;
      pde.insertBefore(svg, pde.childNodes[0]);
      return element._svgIcon = svg;
    }
    return null;
  }

  /**
   * Removes an icon from the given element
   */
  removeIcon(element) {
    if (element._svgIcon) {
      const elem = element;
      elem.removeChild(element._svgIcon);
      element._svgIcon = null;
    }
  }

  _targetIsRTL(target) {
    if (this.__targetIsRTL == null) {
      if (this.useGlobalRtlAttribute) {
        var globalElement =
          (document.body && document.body.hasAttribute('dir')) ?
            document.body :
            document.documentElement;

        this.__targetIsRTL = globalElement.getAttribute('dir') === 'rtl';
      } else {
        if (target && target.nodeType !== Node.ELEMENT_NODE) {
          target = target.host;
        }

        this.__targetIsRTL =
          target && window.getComputedStyle(target).direction === 'rtl';
      }
    }

    return this.__targetIsRTL;
  }

  _nameChanged() {
    this._meta.value = null;
    this._meta.key = this.name;
    this._meta.value = this;
    window.dispatchEvent(new CustomEvent('iron-iconset-added', {
      bubbles: true,
      composed: true,
      detail: this,
    }));
  }

  _createIconMap() {
    var icons = Object.create(null);
    var template = this.querySelector('template');
    var orig = template ? template.content : this;
    orig.querySelectorAll('svg > defs > [id]').forEach(function(icon) {
      icons[icon.id] = icon;
    });
    return icons;
  }

  _cloneIcon(id, mirrorAllowed) {
    this._icons = this._icons || this._createIconMap();
    return this._prepareSvgClone(this._icons[id], this.iconWidth, this.iconHeight, mirrorAllowed);
  }

  _prepareSvgClone(sourceSvg, width, height, mirrorAllowed) {
    if (sourceSvg) {
      var content = sourceSvg.cloneNode(true);
      var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      var viewBox = content.getAttribute('viewBox') || '0 0 ' + width + ' ' + height;
      var overflow = this.overflow ? 'visible' : 'hidden';
      var cssText = `pointer-events: none; display: block; width: 100%; height: 100%; overflow: ${overflow}`;

      if (mirrorAllowed && content.hasAttribute('mirror-in-rtl')) {
        cssText +=
          '-webkit-transform:scale(-1,1);transform:scale(-1,1);transform-origin:center;';
      }

      svg.setAttribute('viewBox', viewBox);
      svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
      svg.setAttribute('focusable', 'false');
      svg.style.cssText = cssText;
      svg.appendChild(content).removeAttribute('id');
      return svg;
    }
    return null;
  }
}

customElements.define(CellsIconsetSvg.is, CellsIconsetSvg);
