<!doctype html>
<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<html>
  <head>
    <title>cells-image test</title>
    <script src="../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../node_modules/mocha/mocha.js"></script>
    <script src="../node_modules/wct-mocha/wct-mocha.js"></script>
    <script src="../node_modules/chai/chai.js"></script>
    <script src="../node_modules/sinon/pkg/sinon.js"></script>
    <script src="../node_modules/@polymer/test-fixture/test-fixture.js"></script>
    <script src="../node_modules/sinon-chai/lib/sinon-chai.js"></script>
  </head>
  <body>
    <style>
      .fixed-width-container {
        width: 500px;
      }

      .fixed-width-container cells-image {
        width: 100%;
        --cells-image-width: 100%;
      }

      .fixed-height-container {
        height: 500px;
      }

      .fixed-height-container cells-image {
        height: 100%;
        --cells-image-height: 100%;
      }
    </style>

    <test-fixture id="TrivialImage">
      <template>
        <cells-image></cells-image>
      </template>
    </test-fixture>

    <test-fixture id="FixedWidthContainer">
      <template>
        <div class="fixed-width-container">
          <cells-image></cells-image>
        </div>
      </template>
    </test-fixture>

    <test-fixture id="FixedHeightContainer">
      <template>
        <div class="fixed-height-container">
          <cells-image></cells-image>
        </div>
      </template>
    </test-fixture>

    <test-fixture id="PreventLoad">
      <template>
        <cells-image prevent-load src="./cells.svg"></cells-image>
      </template>
    </test-fixture>

    <script type="module">
      import './test.js';

      suite('<cells-image>', () => {
        function randomImageUrl() {
          return './cells.svg?' + Math.random();
        }

        let image;

        suite('basic behavior', () => {
          setup(async () => {
            image = fixture('TrivialImage');
            await image.updateComplete;
          });

          test('loading, loaded, error are false before any src is set', () => {
            assert.isFalse(image.loading);
            assert.isFalse(image.loaded);
            assert.isFalse(image.error);
          });

          test('loading, loaded, error are false when src is set to empty string', (done) => {
            image.addEventListener('loaded-changed', function onLoadedChanged() {
              if (image.loaded) {
                image.removeEventListener('loaded-changed', onLoadedChanged);
                image.addEventListener('loaded-changed', function onLoadedChanged2() {
                  image.removeEventListener(
                      'loaded-changed', onLoadedChanged2);
                  assert.isFalse(image.loading);
                  assert.isFalse(image.loaded);
                  assert.isFalse(image.error);
                  done();
                });
                assert.isFalse(image.loading);
                assert.isTrue(image.loaded);
                assert.isFalse(image.error);
                image.src = '';
              }
            });
            image.src = randomImageUrl();
          });

          test('can load images given a src', (done) => {
            image.addEventListener('loaded-changed', function onLoadedChanged() {
              image.removeEventListener('loaded-changed', onLoadedChanged);

              try {
                assert.isTrue(image.loaded);
                done();
              } catch (e) {
                done(e);
              }
            });
            image.src = randomImageUrl();
          });

          test('will reload images when src changes', (done) => {
            let loadCount = 0;

            image.addEventListener('loaded-changed', function onLoadedChanged() {
              if (image.loaded === true) {
                loadCount++;

                if (loadCount === 2) {
                  image.removeEventListener('loaded-changed', onLoadedChanged);
                  done();
                } else {
                  image.src = randomImageUrl();
                }
              }
            });

            image.src = randomImageUrl();
          });

          test('error property is set when the image fails to load', (done) => {
            image.addEventListener('error-changed', function onErrorChanged() {
              assert.isTrue(image.error, 'image has error property set');
              image.removeEventListener('error-changed', onErrorChanged);
              done();
            });

            image.src = '/this_image_should_not_exist.jpg';
          });

          test('placeholder is hidden after loading when src is changed from invalid to valid', (done) => {
            image.preload = true;

            image.addEventListener('error-changed', function onErrorChanged() {
              image.removeEventListener('error-changed', onErrorChanged);

              assert.equal(image.loading, false, 'errored image loading = false');
              assert.equal(image.loaded, false, 'errored image loaded = false');
              assert.equal(image.error, true, 'errored image error = true');

              image.addEventListener('loaded-changed', function onLoadedChanged() {
                if (!image.loaded) {
                  return;
                }

                image.removeEventListener('loaded-changed', onLoadedChanged);

                assert.equal(image.loading, false, 'ok image loading = false');
                assert.equal(image.loaded, true, 'ok image loaded = true');
                assert.equal(image.error, false, 'ok image error = false');
                image.updateComplete.then(() => {
                  assert.equal(getComputedStyle(image.shadowRoot.querySelector('#placeholder')).display, 'none', 'placeholder has style.display = none');
                  done();
                });
              });

              image.src = randomImageUrl();
            });

            image.src = '/this_image_should_not_exist.jpg';
          });

          test('image is not shown below placeholder if previous image was loaded with sizing on and current image fails to load', (done) => {
            image.preload = true;
            image.sizing = 'cover';

            image.addEventListener('loaded-changed', function onLoadedChanged() {
              if (!image.loaded) {
                return;
              }
              image.removeEventListener('loaded-changed', onLoadedChanged);
              image.updateComplete.then(() => {
                assert.notEqual(getComputedStyle(image.shadowRoot.querySelector('#sizedImgDiv')).backgroundImage, 'none', 'image visible after successful load');
                assert.equal(getComputedStyle(image.shadowRoot.querySelector('#placeholder')).display, 'none', 'placeholder hidden after successful load');

                image.addEventListener('error-changed', function onErrorChanged() {
                  if (!image.error) {
                    return;
                  }
                  image.removeEventListener('error-changed', onErrorChanged);
                  image.updateComplete.then(() => {
                    assert.equal(getComputedStyle(image.shadowRoot.querySelector('#sizedImgDiv')).backgroundImage, 'none', 'image hidden after failed load');
                    assert.notEqual(getComputedStyle(image.shadowRoot.querySelector('#placeholder')).display, 'none', 'placeholder visible after failed load');

                    done();
                  });
                });

                image.src = '/this_image_should_not_exist.jpg';
              });
            });

            image.src = randomImageUrl();
          });
        });

        suite('preventLoad', () => {
          let image2;

          setup(async () => {
            image = fixture('TrivialImage');
            await image.updateComplete;
          });

          test('The `prevent-load` attribute prevents the image from loading when created.', async () => {
            let image = fixture('PreventLoad');
            await image.updateComplete;
            // The image should still be in the initial state even though it has a valid `src` attribute.
            assert.equal(image.loading, false);
            assert.equal(image.loaded, false);
            assert.equal(image.error, false);
          });

          test('If `preventLoad` is true, then changing `src` does not start loading the image.', async () => {
            let attemptedLoadSpy = sinon.spy();
            image.preventLoad = true;
            await image.updateComplete;
            image.addEventListener('loading-changed', attemptedLoadSpy);
            assert.notOk(image.loading);
            image.src = randomImageUrl();
            sinon.assert.notCalled(attemptedLoadSpy);
          });

          test('If the image with URL `src` is not currently loaded and `preventLoad` changes to true, then the image at `src` is loaded.', (done) => {
            let attemptedLoadSpy = sinon.spy();
            image.preventLoad = true;
            image.addEventListener('loaded-changed', attemptedLoadSpy);
            image.src = randomImageUrl();
            sinon.assert.notCalled(attemptedLoadSpy);
            image.removeEventListener('loaded-changed', attemptedLoadSpy);

            image.addEventListener('loaded-changed', function onLoadedChanged() {
              if (!image.loaded) {
                return;
              }
              image.removeEventListener('loaded-changed', onLoadedChanged);

              done();
            });

            image.preventLoad = false;
          });

          test('If the image with URL `src` is currently loaded, then toggling `preventLoad` does not reload the image.', (done) => {
            let image = fixture('PreventLoad');

            assert.equal(image.loading, false);
            assert.equal(image.loaded, false);
            assert.equal(image.error, false);

            image.addEventListener('loaded-changed', function onLoadedChanged() {
              image.removeEventListener('loaded-changed', onLoadedChanged);

              assert.equal(image.loading, false);
              assert.equal(image.loaded, true);
              assert.equal(image.error, false);

              // `loading` should not change after this point.
              let failed = false;
              image.addEventListener('loading-changed', function onLoadingChanged() {
                failed = true;
                done(new Error('Toggling `preventLoad` reloaded the image.'));
              });

              image.preventLoad = true;
              image.preventLoad = false;

              if (!failed) {
                done();
              }
            });

            image.preventLoad = false;
            image.src = randomImageUrl();
          });

          test('image is loaded when prevent-load is set to false after cycling `src`', (done) => {
            const initialSrc = randomImageUrl();

            image.addEventListener('loaded-changed', async function loadedChanged() {
              image.removeEventListener('loaded-changed', loadedChanged);

              assert.isTrue(image.loaded);
              assert.isFalse(image.loading);
              assert.isFalse(image.error);

              image.preventLoad = true;
              image.src = randomImageUrl();
              await image.updateComplete;
              image.src = initialSrc;
              await image.updateComplete;

              assert.isFalse(image.loaded);
              assert.isFalse(image.loading);
              assert.isFalse(image.error);

              image.addEventListener('loaded-changed', function loadedChanged() {
                image.removeEventListener('loaded-changed', loadedChanged);

                assert.isTrue(image.loaded);
                assert.isFalse(image.loading);
                assert.isFalse(image.error);

                done();
              });

              image.preventLoad = false;
            });

            image.src = initialSrc;
          });
        });

        suite('--cells-image-width, --cells-image-height', () => {
          let fixedWidthContainer;
          let fixedWidthCellsImage;
          let fixedHeightContainer;
          let fixedHeightCellsImage;

          setup(async () => {
            fixedWidthContainer = fixture('FixedWidthContainer');
            fixedWidthCellsImage = fixedWidthContainer.querySelector('cells-image');
            fixedHeightContainer = fixture('FixedHeightContainer');
            fixedHeightCellsImage = fixedHeightContainer.querySelector('cells-image');
            await Promise.all([fixedWidthContainer.updateComplete, fixedWidthCellsImage.updateComplete, fixedHeightContainer.updateComplete, fixedHeightCellsImage.updateComplete]);;
          });

          test('100% width image fills container', (done) => {
            fixedWidthCellsImage.shadowRoot.querySelector('#img').addEventListener('load', function onLoadedChanged(e) {
              fixedWidthCellsImage.shadowRoot.querySelector('#img').removeEventListener('load', onLoadedChanged);

              const containerRect = fixedWidthContainer.getBoundingClientRect();
              const cellsImageRect = fixedWidthCellsImage.getBoundingClientRect();
              const wrappedImageRect =fixedWidthCellsImage.shadowRoot.querySelector('#img').getBoundingClientRect();

              assert.closeTo(containerRect.width, 500, 0.5);
              assert.closeTo(cellsImageRect.width, 500, 0.5);
              assert.closeTo(wrappedImageRect.width, 500, 0.5);

              done();
            });

            fixedWidthCellsImage.src = randomImageUrl();
          });

          test('100% height image fills container', function(done) {
            fixedHeightCellsImage.shadowRoot.querySelector('#img').addEventListener('load', function onLoadedChanged(e) {
              fixedHeightCellsImage.shadowRoot.querySelector('#img').removeEventListener('load', onLoadedChanged);

              const containerRect = fixedHeightContainer.getBoundingClientRect();
              const cellsImageRect = fixedHeightCellsImage.getBoundingClientRect();
              const wrappedImageRect = fixedHeightCellsImage.shadowRoot.querySelector('#img').getBoundingClientRect();

              assert.closeTo(containerRect.height, 500, 0.5);
              assert.closeTo(cellsImageRect.height, 500, 0.5);
              assert.closeTo(wrappedImageRect.height, 500, 0.5);

              done();
            });

            fixedHeightCellsImage.src = randomImageUrl();
          });
        });

        suite('accessibility', () => {
          suite('sizing inactive', () => {
            let image;

            setup(async () => {
              image = fixture('TrivialImage');
              await image.updateComplete;
            });

            test('#sizedImgDiv is hidden', () => {
              const sizedImgDivStyle = window.getComputedStyle(image.shadowRoot.querySelector('#sizedImgDiv'));
              assert.strictEqual(sizedImgDivStyle.display, 'none');
            });

            test('img has no alt text by default', () => {
              assert.isFalse(image.shadowRoot.querySelector('#img').hasAttribute('alt'));
            });

            test('img alt text is empty string when cells-image alt text is empty string', async () => {
              image.alt = '';
              await image.updateComplete;

              assert.isTrue(image.shadowRoot.querySelector('#img').hasAttribute('alt'));
              assert.strictEqual(image.shadowRoot.querySelector('#img').getAttribute('alt'), '');
            });

            test('img alt text matches cells-image alt text when defined', async () => {
              image.alt = 'alt text value';
              await image.updateComplete;

              assert.isTrue(image.shadowRoot.querySelector('#img').hasAttribute('alt'));
              assert.strictEqual(image.shadowRoot.querySelector('#img').getAttribute('alt'), 'alt text value');
            });
          });

          suite('sizing active', () => {
            let image;

            setup(async () => {
              image = fixture('TrivialImage');
              image.sizing = 'cover';
              await image.updateComplete;
            });

            test('inner img is hidden', () => {
              const imgStyle = window.getComputedStyle(image.shadowRoot.querySelector('#img'));
              assert.strictEqual(imgStyle.display, 'none');
            });

            test('#sizedImgDiv has empty aria-label text by default', () => {
              assert.isTrue(image.shadowRoot.querySelector('#sizedImgDiv').hasAttribute('aria-label'));
              assert.strictEqual(image.shadowRoot.querySelector('#sizedImgDiv').getAttribute('aria-label'), '');
            });

            test('#sizedImgDiv has aria-hidden when cells-image alt text is empty string', async () => {
              image.alt = '';
              await image.updateComplete;

              assert.isTrue(image.shadowRoot.querySelector('#sizedImgDiv').hasAttribute('aria-hidden'));
              const hiddenValue = image.shadowRoot.querySelector('#sizedImgDiv').getAttribute('aria-hidden');
              assert.isTrue(hiddenValue === '' || hiddenValue === 'true');
            });

            test('#sizedImgDiv aria-label matches cells-image alt text when defined', async () => {
              image.alt = 'alt text value';
              await image.updateComplete;

              assert.isTrue(image.shadowRoot.querySelector('#sizedImgDiv').hasAttribute('aria-label'));
              assert.strictEqual(image.shadowRoot.querySelector('#sizedImgDiv').getAttribute('aria-label'), 'alt text value');
            });

            test('#sizedImgDiv aria-label text is last path component of src when cells-image alt text is undefined', async () => {
              image.src = '/some/path.components/file.jpg?a=b&c=d#anchor';
              await image.updateComplete;

              assert.isTrue(image.shadowRoot.querySelector('#sizedImgDiv').hasAttribute('aria-label'));
              assert.strictEqual(image.shadowRoot.querySelector('#sizedImgDiv').getAttribute('aria-label'), 'file.jpg');
            });
          });
        });
      });
    </script>
  </body>
</html>
