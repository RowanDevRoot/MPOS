<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>cells-codemirror test</title>
  <script src="../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../node_modules/mocha/mocha.js"></script>
  <script src="../node_modules/wct-mocha/wct-mocha.js"></script>
  <script src="../node_modules/chai/chai.js"></script>
  <script src="../node_modules/sinon/pkg/sinon.js"></script>
  <script src="../node_modules/@polymer/test-fixture/test-fixture.js"></script>
  <script src="../node_modules/sinon-chai/lib/sinon-chai.js"></script>
</head>

<body>

  <test-fixture id="default">
    <template>
      <cells-codemirror></cells-codemirror>
      <p>Hello <b>world</b>!</p>
    </template>
  </test-fixture>

  <test-fixture id="sourceElement">
    <template>
      <cells-codemirror source-element="#sample"></cells-codemirror>
      <div id="sample">
        <p>Hello <b>world</b>!</p>
      </div>
    </template>
  </test-fixture>

  <test-fixture id="lineHighlight">
    <template>
      <cells-codemirror source-element="#sample"></cells-codemirror>
      <div id="sample">
        <p>line 1</p>
        <p>line 2</p>
        <p>line 3</p>
        <p>line 4</p>
      </div>
    </template>
  </test-fixture>

  <script type="module">
    import './test.js';
    suite('cells-codemirror', () => {
      let el;
      let shadowRoot;
      let paragraph;

      setup(function() {
        el = fixture('default')[0];
        shadowRoot = el.shadowRoot;
        paragraph = fixture('default')[1];
      });

      test('Setting "content" calls CodeMirror with the proper configuration', async () => {
        const CodeMirrorStub = sinon.stub(window, 'CodeMirror');

        el.content = paragraph.innerHTML;
        await el.updateComplete;
        const [nodeParam, configParam] = CodeMirrorStub.getCall(0).args;

        assert.equal(nodeParam, shadowRoot.querySelector('#editor'));

        // relevant options
        assert.equal(configParam.value, paragraph.innerHTML.trim());
        assert.equal(configParam.mode, el.mode, `sets mode as ${el.mode}`);
        assert.equal(configParam.autofocus, el.autofocus, `sets autofocus as ${el.autofocus}`);
        assert.equal(configParam.theme, el.theme, `sets theme as ${el.theme}`);
        assert.equal(configParam.tabSize, el.tabSize, `sets tabSize as ${el.tabSize}`);
        assert.equal(configParam.readOnly, el.readonly, `sets readonly as ${el.readonly}`);

        CodeMirrorStub.restore();
      });

      test('Setting "readonly" and "nocursor" disables focusing the editor', async () => {
        const CodeMirrorStub = sinon.stub(window, 'CodeMirror');

        el.readonly = true;
        el.nocursor = true;
        el.content = paragraph.innerHTML;

        await el.updateComplete;
        const [nodeParam, configParam] = CodeMirrorStub.getCall(0).args;

        assert.equal(configParam.readOnly, 'nocursor');

        CodeMirrorStub.restore();
      });

      test('Changing "content" updates the editor', async () => {
        el.content = paragraph.innerHTML;
        el.content = paragraph.innerHTML + '<p></p>';

        await el.updateComplete;
        assert.equal(el.getValue(), el.content);
      });

      test('"getValue()" returns the editor content', async () => {
        assert.isUndefined(el.getValue(), 'calling getValue() when "content" is not set returns nothing');

        el.content = paragraph.innerHTML;
        await el.updateComplete;
        assert.equal(el.getValue(), el.content);
      });

      suite('Using "source-element"', () => {
        let el;
        let content;

        setup(() => {
          el = fixture('sourceElement')[0];
          content = fixture('sourceElement')[1];
        });

        test('Setting "source-element" sets editor value as the sourceElement "innerHTML"', (done) => {
          flush(() => {
            const expectedContent = content.innerHTML.trim();
            assert.equal(el.getValue(), expectedContent);

            done();
          });
        });
      });

      suite('Line highlight', () => {
        let el;
        let content;
        let addLineClassSpy;

        setup(() => {
          el = fixture('lineHighlight')[0];
          content = fixture('lineHighlight')[1];
          el.content = content.innerHTML;
          addLineClassSpy = sinon.spy(el, '_addLineClass');
        });

        teardown(() => {
          addLineClassSpy.restore();
        });

        test('Setting "highlight-lines" as a single value (3) highlights the specified line', async () => {
          el.highlightLines = '3';

          await el.updateComplete;
          assert.isTrue(addLineClassSpy.calledWith(3));
        });

        test('Setting "highlight-lines" as multiple values (1,2) separated by commas highlights the specified lines', async () => {
          el.highlightLines = '1,2';

          await el.updateComplete;
          debugger;
          assert.strictEqual(addLineClassSpy.getCall(0).args[0], 1);
          assert.strictEqual(addLineClassSpy.getCall(1).args[0], 2);
        });

        test('Setting "highlight-lines" as a range (1-3) highlights the lines in the range', async () => {
          el.highlightLines = '1-3';

          await el.updateComplete;
          assert.strictEqual(addLineClassSpy.getCall(0).args[0], 1);
          assert.strictEqual(addLineClassSpy.getCall(1).args[0], 2);
          assert.strictEqual(addLineClassSpy.getCall(2).args[0], 3);
        });

        test('Setting "highlight-lines" with an invalid range (3-1) does not highlight lines', async () => {
          el.highlightLines = '3-1';
          await el.updateComplete;
          assert.isFalse(addLineClassSpy.called);
        });
      });
    });
  </script>
</body>

</html>
