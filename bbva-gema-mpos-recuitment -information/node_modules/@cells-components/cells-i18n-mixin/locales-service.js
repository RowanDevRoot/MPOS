/* global Shadow */
export default class LocalesService {
  get langPath() {
    if (this.langFolderMapping) {
      return this.langFolderMapping[this.lang];
    } else {
      return this.lang;
    }
  }

  get lang() {
    return this._lang;
  }

  get url() {
    return this._url;
  }

  set url(url) {
    // Make sure url ends on slash.
    if (url && url.substr(-1) !== '/') {
      url += '/';
    }

    if (url !== this._url) {
      this._url = url;
      this.fetchLanguage();
    }
  }

  get files() {
    return this._files;
  }

  set files(files) {
    if (files !== this._files) {
      this._files = files;
      this.fetchLanguage();
    }
  }

  constructor(data) {
    this.locales = {};
    this._files = data.files;
    this.disabled = data.disabled;
    this._url = data.url || 'locales/';
    this._lang = data.lang || document.documentElement.lang;
    this.langFolderMapping = data.langFolderMapping;
    this._translationsRequestsPromises = [];
    this.noCache = data.noCache;
    this.unFlattened = data.unFlattened;
  }

  _onLoadLanguage(data, lang, url) {
    this.locales[lang] = this.locales[lang] || {};
    this.locales[lang][url] = data;
    this._refreshNodes();
  }

  _fetch(url, method = 'GET') {
    const request = new XMLHttpRequest();

    return new Promise((resolve, reject) => {
      request.onreadystatechange = () => {
        if (request.readyState !== 4) {
          return;
        }

        if (request.status >= 200 && request.status < 300) {
          resolve(request);
        } else {
          reject({
            status: request.status,
            statusText: request.statusText
          });
        }
      };
      request.open(method, url, true);
      request.send();
    }).catch(() => {});
  }

  fetchLanguage() {
    if (this.disabled || !this.lang || !this.url) {
      return;
    }

    let urls;
    const cacheParam = this.noCache ? `?v=${Date.now()}` : '';

    if (!this.files) {
      const url = `${this.url}${this.langPath}.json${cacheParam}`;
      urls = [ url ];
    } else {
      urls = this.files.map(file => `${this.url}${this.langPath}/${file}.json${cacheParam}`);
    }

    const lang = this.lang;

    const promise = Promise.all(urls.map((currentUrl) =>
      this._fetch(currentUrl)
        .then((response) => JSON.parse(response.responseText))
        .then((data) => this._onLoadLanguage(data, lang, currentUrl))
    )).then(() => {
      const event = new CustomEvent('i18n-language-ready', {
        detail: {
          language: lang
        },
        bubbles: true,
        composed: true
      });

      document.dispatchEvent(event);
    }).catch(() => {});

    this._translationsRequestsPromises.push(promise);

    return promise;
  }

  get translationsRequests() {
    return Promise.all(this._translationsRequestsPromises);
  }

  get currentLocale() {
    return this.locales ? this.locales[this.lang] : false;
  }

  set lang(language) {
    if (language !== this._lang) {
      document.documentElement.lang = language;
      this._lang = language;
      this.fetchLanguage();
      const event = new CustomEvent('i18n-lang-changed', {
        detail: {
          language
        },
        bubbles: true,
        composed: true
      });

      document.dispatchEvent(event);
    }
  }

  /**
   * Translates a string to the current language.
   *
   * @param  {String} msgId String to translate.
   * @return {String} Translated text. If it doesn't exists, returns null.
   */
  getTranslation(msgId) {
    if (!this.currentLocale || !msgId) {
      return null;
    }

    return this._getMessage(this.currentLocale, msgId);
  }

  _getMessage(locale, msgId) {
    for (const key in locale) {
      if (locale[key]) {
        if (this._get(locale[key], msgId)) {
          return this._get(locale[key], msgId);
        }
      }
    }

    return null;
  }

  /**
   * get key from json
   *
   * @param  {Object} obj  Json
   * @param  {String} key  The key to get from the json
   * @return {String}      The key value
   */
  _get(obj, key) {
    return this.unFlattened ? this._getUnflattenedKey(obj, key) : obj[key];
  }

  /**
   * Returns an object from a flattened translation key with dots (`some.nested.key`)
   *
   * @param {Object} obj Json
   * @param {String} key The key to get from json
   */
  _getUnflattenedKey(obj, key) {
    try {
      return key.split('.').reduce((acc, prop) => (acc[prop]), obj);
    } catch (e) {
      return;
    }
  }

  _refreshNodes() {
    const componentsWithI18n = Shadow.querySelectorAll('[has-i18n]');

    componentsWithI18n.forEach((item) => {
      item.updateTranslation();
    });
  }
}
