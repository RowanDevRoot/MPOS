import { html, fixture, assert, fixtureCleanup, aTimeout } from '@open-wc/testing';
import { swapTransition } from '@bbva-web-components/bbva-core-lit-helpers/directives/swap-transition.js';
import { LitElement, css } from 'lit-element';

class CustomComponent extends LitElement {
  static get is() {
    return 'custom-component';
  }

  static get properties() {
    return {
      selected: {
        type: Number
      },
      directiveOptions: {
        type: Object,
        attribute: 'directive-options'
      }
    };
  }

  constructor() {
    super();
    this.selected = 0;
    this.directiveOptions = { add: 'enter', remove: 'leave' };
  }

  static get styles() {
    return css`
      p {
        opacity: .5;
        transition: opacity .1s;
      }
      .enter {
        opacity: 1;
      }
      .leave {
        opacity: .5
      }
      .enter-anim {
        animation: enter-anim .1s;
      }
      .leave-anim {
        animation: leave-anim .1s;
      }
      @keyframes enter-anim {
        from {
          transform: translateX(100vw)
        }
      }
      @keyframes leave-anim {
        to {
          transform: translateX(-100vw)
        }
      }
    `;
  }

  render() {
    return html`
      ${swapTransition(this[`item${this.selected}`], this.directiveOptions )}
    `;
  }

  get item0() {
    return html`<p>Item 0</p>`;
  }

  get item1() {
    return html`<p>Item 1</p>`;
  }

  get item2() {
    return html``;
  }
}
customElements.define(CustomComponent.is, CustomComponent);

suite('swapTransition', () => {
  let el;

  teardown(() => fixtureCleanup());

  suite('Basic', () => {
    setup(async () => {
      el = await fixture(html`
        <custom-component></custom-component>
      `);
      await el.updateComplete;
    });

    test('first element is shown by default', () => {
      const result = `
        <p>Item 0</p>
      `;
      assert.shadowDom.equal(el, result);
    });

    test('changing selected adds leave class to element', async () => {
      el.selected = 1;
      await el.updateComplete;

      const result = `
        <p class="leave">Item 0</p>
      `;
      assert.shadowDom.equal(el, result);
    });

    test('changing selected adds new node with add class', async () => {
      el.selected = 1;
      await el.updateComplete;

      const p = el.shadowRoot.querySelector('p');
      p.dispatchEvent(new CustomEvent('transitionend'));

      await aTimeout(200);

      const result = `
        <p class="enter">Item 1</p>
      `;
      assert.shadowDom.equal(el, result);
    });

    test('omitting remove directive option uses default one', async () => {
      el.directiveOptions = { add: 'enter' };
      await el.updateComplete;

      const result = `
        <p class="hidden">Item 0</p>
      `;
      assert.shadowDom.equal(el, result);
    });

    test('omitting add directive option uses default one', async () => {
      el.directiveOptions = { remove: 'leave' };
      el.selected = 1;
      await el.updateComplete;

      const p = el.shadowRoot.querySelector('p');
      p.dispatchEvent(new CustomEvent('transitionend'));

      await aTimeout(200);

      const result = `
        <p class="visible">Item 1</p>
      `;
      assert.shadowDom.equal(el, result);
    });

    test('using no directive options at all uses default classes', async () => {
      el.directiveOptions = undefined;
      el.selected = 1;
      await el.updateComplete;

      const result = `
        <p class="hidden">Item 0</p>
      `;
      assert.shadowDom.equal(el, result);
    });

    test('using empty strings as options set no classes', async () => {
      el.directiveOptions = { add: '', remove: ''};
      el.selected = 1;
      await el.updateComplete;

      const result = `
        <p>Item 0</p>
      `;
      assert.shadowDom.equal(el, result);
    });

    test('setting empty node adds no classes', async () => {
      el.selected = 2;
      await el.updateComplete;

      const p = el.shadowRoot.querySelector('p');
      p.dispatchEvent(new CustomEvent('transitionend'));

      await aTimeout(200);

      const result = ``;
      assert.shadowDom.equal(el, result);
    });

    test('changing selected with animations instead of transitions also adds classes', async () => {
      el.directiveOptions = { add: 'enter-anim', remove: 'leave-anim' };
      el.selected = 1;
      await el.updateComplete;

      const p = el.shadowRoot.querySelector('p');
      p.dispatchEvent(new CustomEvent('animationend'));

      await aTimeout(200);

      const enterResult = `
        <p class="enter-anim">Item 1</p>
      `;
      assert.shadowDom.equal(el, enterResult);
    });
  });
});
