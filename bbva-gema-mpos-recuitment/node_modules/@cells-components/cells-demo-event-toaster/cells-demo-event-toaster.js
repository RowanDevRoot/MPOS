import { LitElement, html, css, } from 'lit-element';
import { getComponentSharedStyles, } from '@cells-components/cells-lit-helpers/cells-lit-helpers.js';
import styles from './cells-demo-event-toaster-styles.js';
import '@polymer/paper-toast/paper-toast.js';
/**
`<cells-demo-event-toaster>` adds an event listener for each event from the `events` Array.

So every time one of those events is triggered, a `paper-toast` element will open with the event's information.

Example:

```html
<cells-demo-event-toaster events="[[eventsArray]]"></cells-demo-event-toaster>
```

## Styling

The following custom properties and mixins are available for styling:

### Custom Properties
| Custom Property                            | Selector       | CSS Property | Value   |
| ------------------------------------------ | -------------- | ------------ | ------- |
| --cells-demo-event-toaster-highlight-color | .highlight     | color        |  yellow |
| --cells-demo-event-toaster-vertical-top    | ]) paper-toast | margin-top   |  160px  |
### @apply
| Mixins                               | Selector   | Value |
| ------------------------------------ | ---------- | ----- |
| --cells-demo-event-toaster           | :host      | {}    |
| --cells-demo-event-toaster-highlight | .highlight | {}    |

 * @customElement
 * @extends {LitElement}
 * @hero cells-demo-event-toaster.jpg
 * @demo demo/index.html
 */
class cellsDemoEventToaster extends LitElement {

  static get is() {
    return 'cells-demo-event-toaster';
  }

  static get properties() {
    return {
      /**
       * An array of Strings (names of the events)
       *
       * ```js
       * [ 'open-component', 'close-component', 'do-something' ]
       * ```
       */
      events: {
        type: Array
      },

      _events: {
        type: Array
      },

      /**
       * Duration of the paper-toast.
       */
      duration: {
        type: Number
      },

      /**
       * Toast status.
       */
      opened: {
        type: Boolean
      },

      /**
       * Allow multiple toast to be visible at the same time.
       */
      multiple: {
        type: Boolean
      },

      /**
       * set the position of toast in vertical align the possible values is top or bottom
       */
      verticalAlign: {
        type: String,
        attribute: 'vertical-align',
      },

      /**
       * The element that should be used to position the element. If not set, it will default to the parent node.
       */
      positionTarget: {
        type: Element,
      },
    }
  }

  constructor() {
    super();
    this.duration = 4000;
    this.opened = false;
    this.multiple = false;
    this.verticalAlign = 'bottom';
    this._events = [];
    this._setToast = this._setToast.bind(this);
  }

  updated(changedProps) {
    if (changedProps.has('events')) {
      this._events = this._computeEvents(this.events);
      this._eventsChanged(this.events);
    }
  }

  get _duration() {
    return this._computeDuration(this.duration, this.multiple);
  }

  static get shadyStyles() {
    return `
      ${styles.cssText}
      ${getComponentSharedStyles('cells-demo-dropdown-menu-shared-styles')}
    `;
  }

  render() {
    const items = this._events.map(item => {
      return html`
      <div class="inner-toast" ?visible="${item.opened}" style="order: ${item.order}">
        <p>Fired: <span class="highlight">${item.name}</span></p>
        ${ item.payload ? html`
          <p>With payload: <span class="highlight">${item.payload}</span></p>
        ` : '' }
        <p>Bubbles: <span class="highlight">${item.bubbles}</span></p>
      </div>
    `});
    return html`
      <style>${this.constructor.shadyStyles}</style>

      <paper-toast
        id="toast"
        .opened="${this.opened}"
        .duration="${this._duration}"
        .verticalAlign="${this.verticalAlign}"
        .positionTarget="${this.positionTarget}"
        @opened-changed="${(e) => this._setOpenedState(e)}"
        @click="${(e) => this._closeToast(e)}">

        ${items}

      </paper-toast>
    `;
  }

  _eventsChanged(events) {
    events.forEach(event => window.addEventListener(event, this._setToast, true));
  }

  _computeEvents(events) {
    return events.map(event => {
      return {
        name: event,
        opened: false,
        payload: false,
        timeout: null,
        order: 0,
        bubbles: 'false',
      };
    });
  }

  _computeDuration(duration, multiple) {
    return multiple ? 0 : duration;
  }

  _setToast(e) {
    var item = this._events.find(event => event.name === e.type);
    var index = this._events.findIndex(event => event.name === e.type);
    this._events[index].opened = true;
    this._events[index].payload = this._setEventPayload(e);
    this._events[index].bubbles = String(event.bubbles);
    this.requestUpdate();
    this._openToast(item, index);
  }

  async _openToast(item, index) {
    if (!this.multiple && this.shadowRoot.querySelector('#toast').opened) {
      this.shadowRoot.querySelector('#toast').cancel();
      this._events[index].opened = true;

    }

    if (this.multiple) {
      this._resetOpenedState(item, index);
      this._setOrder(item, index);
    }
    this.requestUpdate();
    await this.updateComplete;

    this.shadowRoot.querySelector('#toast').refit();
    this.shadowRoot.querySelector('#toast').open();
  }

  _closeToast() {
    this.shadowRoot.querySelector('#toast').close();
  }

  _resetOpenedState(item, index) {
    var asyncTask = setTimeout(() => {
      this._events[index].opened = false;
      this.requestUpdate();
    }, this.duration);

    // save the async reference to cancel it later when the toast is closed
    this._events[index].timeout = asyncTask;
  }

  /**
   * Order items using "order" CSS property.
   * Give the highest value (events.length) to the last opened toast and decrease
   * the order of other previously opened toasts by 1.
   * We are using flex-direction: column-reverse, so the order value has to be the highest to appear
   * at the beginning.
   */
  _setOrder(item, index) {
    this._events.forEach((event, eventIndex) => {
      if (event.order > 0) {
        this._events[eventIndex].order = event.order - 1;
      }
    });

    this._events[index].order = this._events.length;
  }

  _setOpenedState(e) {
    this.opened = e.detail.value;

    if (!this._events) {
      return;
    }

    if (e.detail.value === false) {
      this._events.forEach((event, index) => {
        this._events[index].opened = false;
        this.requestUpdate();
        clearTimeout(event.timeout);
      });
    }
  }

  _setEventPayload(e) {
    if (e.detail === null || e.detail === undefined) {
      return false;
    }

    var isStringifiable = true;

    try {
      JSON.stringify(e.detail);
    } catch (er) {
      isStringifiable = false;
    }

    if (typeof e.detail.nodeName === 'string') {
      console.info('[cells-demo-event-toaster]: Payload of ' + e.type, e.detail);
      return '[HTMLElement] ' + e.detail.nodeName + ' (more info in console)';
    }

    if (!isStringifiable) {
      console.info('[cells-demo-event-toaster]: Payload of ' + e.type, e.detail);
      return 'Payload couldn`t be stringifiable (payload info in console)';
    }

    if (JSON.stringify(e.detail) !== '{}') {
      return JSON.stringify(e.detail);
    }

    return false;
  }
}

customElements.define(cellsDemoEventToaster.is, cellsDemoEventToaster);
