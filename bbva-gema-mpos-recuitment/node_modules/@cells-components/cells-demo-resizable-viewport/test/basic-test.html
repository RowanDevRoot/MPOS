<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

  <title>cells-demo-resizable-viewport test</title>

  <script src="../../../../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../../../node_modules/wct-browser-legacy/browser.js"></script>
  <script type="module">

  </script>

</head>

<body>
  <test-fixture id="default">
    <template>
      <cells-demo-resizable-viewport></cells-demo-resizable-viewport>
    </template>
  </test-fixture>

  <script type="module">
    import '../cells-demo-resizable-viewport.js';
    import '@polymer/iron-test-helpers/mock-interactions.js';

    suite('<cells-demo-resizable-viewport>', () => {
      let el;
      let firstBar;
      let secondBar;
      let spy;
      let clock;

      setup(async () => {
        el = fixture('default');
        el.breakpoints = { 'a': { width: 100 }, 'b': { width: 200 } };
        await el.updateComplete;
        spy = sinon.spy();
        el.addEventListener('selected-breakpoint-changed', spy);

        clock = sinon.useFakeTimers();
        await el.updateComplete;
        firstBar = el.shadowRoot.querySelector('.bp__bar');
        secondBar = el.shadowRoot.querySelectorAll('.bp__bar')[1];
      });

      teardown(() => {
        clock.restore();
      });

      suite('setting breakpoints property', () => {
        test('breakpoints are sorted by width in descending order', () => {
          assert.equal(firstBar.dataset.id, 'b');
          assert.equal(secondBar.dataset.id, 'a');
        });
      });

      suite('selecting a breakpoint', () => {
        test('selected-breakpoint-changed event is fired', async () => {
          firstBar.click();
          await el.updateComplete;
          clock.tick(100);
          await el.updateComplete;
          assert.isTrue(spy.called, 'selected-breakpoint-changed event is fired');
        });
      });

      suite('dragging', () => {
        setup(async () => {
          el.selectedKey = 'a'; // secondBar
          return await el.updateComplete;
        });

        test('vertical dragging does not change breakpoint width', async () => {
          MockInteractions.track(secondBar, 0, 10);
          await el.updateComplete;
          clock.tick(100);
          await el.updateComplete;
          assert.isTrue(spy.called, 'selected-breakpoint-changed event is fired');
        });

        test('horizontal dragging changes breakpoint width', async () => {
          MockInteractions.track(secondBar, 10, 0);
          await el.updateComplete;
          assert.isTrue(spy.called, 'selected-breakpoint-changed event is fired');
          assert.equal(spy.getCall(0).args[0].detail.value.width, 120, 'event detail width is 120');
        });
      });

      suite('reset button', () => {
        let btn;

        setup(() => {
          btn = el.shadowRoot.querySelector('button');
        });

        test('is hidden by default', () => {
          assert.isTrue(btn.hidden);
        });

        test('is visible after changing a breakpoint width', async () => {
          let resetBtnInitialState = btn.hidden;

          MockInteractions.track(secondBar, 10, 0);

          await el.updateComplete;

          assert.notEqual(btn.hidden, resetBtnInitialState);
          assert.isFalse(btn.hidden);
        });

        test('clicking on it resets breakpoints', () => {
          sinon.spy(el, 'reset');
          btn.click();
          clock.tick(100);
          assert.isTrue(el.reset.calledOnce);
        });
      });

    });
  </script>
</body>

</html>
