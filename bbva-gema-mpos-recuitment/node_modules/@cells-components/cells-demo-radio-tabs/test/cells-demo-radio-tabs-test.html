<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>cells-demo-radio-tabs test</title>
  <script src="../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../node_modules/mocha/mocha.js"></script>
  <script src="../node_modules/wct-mocha/wct-mocha.js"></script>
  <script src="../node_modules/chai/chai.js"></script>
  <script src="../node_modules/sinon/pkg/sinon.js"></script>
  <script src="../node_modules/@polymer/test-fixture/test-fixture.js"></script>
  <script src="../node_modules/sinon-chai/lib/sinon-chai.js"></script>
</head>

<body>

  <test-fixture id="default">
    <template>
      <cells-demo-radio-tabs options='["uno", "dos"]'></cells-demo-radio-tabs>
      <cells-demo-radio-tabs options='["uno", "dos"]'></cells-demo-radio-tabs>
    </template>
  </test-fixture>

  <test-fixture id="icons">
    <template>
      <cells-demo-radio-tabs options='[{"icon": "any", "label": "One"}, {"icon": "uuu", "label": "Two"}]' icon-size="18"></cells-demo-radio-tabs>
    </template>
  </test-fixture>

  <test-fixture id="mouseEvents">
    <template>
      <cells-demo-radio-tabs notify-mouse-events options='["uno", "dos"]'></cells-demo-radio-tabs>
    </template>
  </test-fixture>

  <script type="module">
  import './test.js';

  suite('<cells-demo-radio-tabs>', function() {
      var el;
      var setTimeoutStub;

      suiteSetup(function() {
        setTimeoutStub = sinon.stub(window, 'setTimeout');
      });

      suiteTeardown(function() {
        window.setTimeout.restore();
      });

      setup(async () => {
        el = fixture('default')[0];
        return await el.updateComplete;
      });

      test('prints the same number of items as options.length property', () => {
        assert.equal(el.shadowRoot.querySelectorAll('label').length, el.options.length);
      });

      test('sets an unique input name for each component instance', async () => {
        var el2 = fixture('default')[1];
        await el2.updateComplete;
        var nameInstance1 = el.shadowRoot.querySelector('input').getAttribute('name');
        var nameInstance2 = el2.shadowRoot.querySelector('input').getAttribute('name');
        assert.notEqual(nameInstance1, nameInstance2);
      });

      test('sets the selected option index as selected (checked)', async () => {
        el.selected = 1;
        await el.updateComplete;
        var secondOption = el.shadowRoot.querySelectorAll('input')[el.selected];
        assert.isTrue(secondOption.checked);
      });

      test('sets the indicator width as 100% / options.length', (done) => {
        el.options = ["tres", "cuatro"];
        el.addEventListener('cells-demo-radio-tabs-styles-updated', function(e) {
          assert.equal(e.detail.itemWidth, '50%', 'Event detail contains the new itemWidth');
          assert.equal(window.getComputedStyle(el).getPropertyValue('--cells-demo-radio-tabs-item-width'), '50%');
          done();
        });
      });

      test('translates the indicator in the X axis 100% * selected index', async () => {
        el.options = [1, 2, 3];
        el.selected = 2;
        await el.updateComplete;
        assert.equal(el.shadowRoot.querySelector('#indicator').style.transform, `translateX(calc(${100 * el.selected}%))`);
      });

      test('does not translate the indicator if the selected value is greater than options.length or lower than zero', function() {
        const indicator = el.shadowRoot.querySelector('#indicator');
        var currentTransformStyle = window.getComputedStyle(indicator).transform;
        el.selected = 2;
        assert.equal(window.getComputedStyle(indicator).transform, currentTransformStyle);
        el.selected = -1;
        assert.equal(window.getComputedStyle(indicator).transform, currentTransformStyle);
      });

      test('sets selected property after changing selected option', function(done) {
        var secondOption = el.shadowRoot.querySelectorAll('label')[1];
        secondOption.click();
        assert.equal(el.selected, 1);
        done();
      });

      test('selected property is set as notifiable', async () => {
        var spy = sinon.spy();
        el.addEventListener('selected-changed', spy);
        el.selected = 1;
        await el.updateComplete;
        assert.isTrue(spy.calledOnce);
      });

      test('Should notify event with selected payload when it was selected', async () => {
        sinon.spy(el, 'dispatchEvent');
        el.shadowRoot.querySelectorAll('label')[1].click();
        await el.updateComplete;
        expect(el.dispatchEvent.args[0][0].type).eql('selected-tab');
        expect(el.dispatchEvent.args[0][0].detail).eql(1);
        el.dispatchEvent.restore();
      });

      test('sets option as text label', () => {
        var firstLabel = el.shadowRoot.querySelector('.label');
        var firstObjLabel = el.shadowRoot.querySelectorAll('.label')[1];
        assert.isTrue(firstObjLabel.hidden, 'label for item with label key is hidden');
        assert.equal(el.options[0], firstLabel.innerText);
      });

      test('icon is hidden', async () => {
        var firstIcon = el.shadowRoot.querySelector('.icon');
        assert.isTrue(firstIcon.hidden);
      });

      test('changing options resets the selected value if necessary', async () => {
        el.options = ['one', 'dos', 'catorce'];
        el.selected = 2;
        await el.updateComplete;
        el.options = ['uno', 'dos'];
        await el.updateComplete;
        assert.equal(el.selected, 0, 'selected is set to 0 because 2 does not exist in current options');
      });
    });

    suite('With icons (objects as options)', function() {
      var el;
      var firstLabel;
      var firstSimpleLabel;
      var firstIcon;

      setup(async () => {
        el = fixture('icons');
        await el.updateComplete;
        firstSimpleLabel = el.shadowRoot.querySelector('.label');
        firstLabel = el.shadowRoot.querySelectorAll('.label')[1];
        firstIcon = el.shadowRoot.querySelector('.icon');
      });

      test('sets option.label as text label', function() {
        assert.isTrue(firstSimpleLabel.hidden, 'simple label is hidden');
        assert.equal(el.options[0].label, firstLabel.innerText);
      });

      test('icon is not hidden if option.icon is provided', function() {
        assert.isFalse(firstIcon.hidden);
      });

      test('iron-icon icon property is set as option.icon', function() {
        assert.equal(firstIcon.icon, el.options[0].icon);
      });

      test('icon has width and height equal to iconSize', async () => {
        el.iconSize = 20;
        await el.updateComplete;
        assert.equal(firstIcon.size, el.iconSize);
      });
    });

    suite('Mouse events (mouseenter / mouseleave)', function() {
      var el;
      var firstTab;

      setup(async () => {
        el = fixture('mouseEvents');
        await el.updateComplete;
        firstTab = el.shadowRoot.querySelector('label');
      });

      test('setting "notifyMouseEvents" to true fires event "tab-mouseevent" index of the event target and the event type', function() {
        var eventSpy = sinon.spy();
        el.addEventListener('tab-mouseevent', eventSpy);

        ['mouseenter', 'mouseleave'].forEach(function(event, index) {
          firstTab.dispatchEvent(new Event(event));
          assert.equal(eventSpy.getCall(index).args[0].detail.index, 0, 'event detail.index contains the current target');
          assert.equal(eventSpy.getCall(index).args[0].detail.type, event, 'event detail.type contains the event type');
        });
      });

      test('does not fire "tab-mouseevent" when "notifyMouseEvents" is set to false (default)', function() {
        el.notifyMouseEvents = false;
        var eventSpy = sinon.spy();
        el.addEventListener('tab-mouseevent', eventSpy);

        ['mouseenter', 'tmouseleave'].forEach(function(event) {
          firstTab.dispatchEvent(new Event(event));
          assert.isFalse(eventSpy.called);
        });
      });
    });

    suite('Keyboard events', function() {
      var el;
      var firstLabel;
      var TAB_KEY = 9;
      var ENTER_KEY = 13;
      var SPACE_KEY = 32;

      setup(async () => {
        el = fixture('default')[0];
        await el.updateComplete;
        firstLabel = el.shadowRoot.querySelectorAll('label')[0];
      });

      test('Items can be navigated using tab key without activating them', async () => {
        el.selected = 0;
        MockInteractions.keyDownOn(firstLabel, TAB_KEY);
        await el.updateComplete;
        assert.notEqual(el.selected, 1, 'selected is not modified');
      });

      test('Pressing enter or space in a focused tab sets it as selected', function() {
        [ENTER_KEY, SPACE_KEY].forEach(function(keyCode) {
          el.selected = 1;
          MockInteractions.keyDownOn(firstLabel, keyCode);
          assert.equal(el.selected, 0, 'selected has been changed');
        });
      });
    });
  </script>
</body>

</html>
