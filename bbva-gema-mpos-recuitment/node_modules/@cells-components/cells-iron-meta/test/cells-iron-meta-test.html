<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>cells-iron-meta test</title>
  <script src="../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../node_modules/mocha/mocha.js"></script>
  <script src="../node_modules/wct-mocha/wct-mocha.js"></script>
  <script src="../node_modules/chai/chai.js"></script>
  <script src="../node_modules/sinon/pkg/sinon.js"></script>
  <script src="../node_modules/@polymer/test-fixture/test-fixture.js"></script>
  <script src="../node_modules/sinon-chai/lib/sinon-chai.js"></script>
</head>

<body>

  <test-fixture id="default">
    <template>
      <cells-iron-meta></cells-iron-meta>
    </template>
  </test-fixture>

  <script type="module">
    import {CellsIronMeta,} from './test.js';
    suite('basic', () => {
      test('byKey', () => {
        const meta = new CellsIronMeta({ key: 'info', value: 'foo/bar', });
        assert.equal(meta.value, 'foo/bar');
      });

      test('list', () => {
        const meta = new CellsIronMeta({ key: 'info', value: 'foo/bar', });
        assert.equal(meta.list.length, 1);
      });

      test('getting `list` does not throw if no objects of the given type exist', () => {
        const meta = new CellsIronMeta({ type: 'NO ITEMS OF THIS TYPE', });
        assert.doesNotThrow(() => {
          // eslint-disable-next-line no-unused-expressions
          meta.list;
        });
      });

      test('constructor with no arguments', () => {
        assert.doesNotThrow(() => {
          // eslint-disable-next-line no-new
          new CellsIronMeta();
        });
      });
    });

    suite('cells-iron-meta', () => {
      suite('basic behavior', () => {
        let meta;
        setup(() => {
          meta = new CellsIronMeta({ key: 'info', value: 'foo/bar', });
        });
        teardown(() => {
          meta.value = null;
        });

        test('can be assigned alternative values', () => {
          meta.value = 'foobar';
          meta.value = 'barfoo';
          assert.equal(meta.list[0], 'barfoo');
        });

        test('can access same-type meta values by key', () => {
          assert.equal(meta.byKey(meta.key), meta.value);
        });

        test('yields a list of same-type meta data', () => {
          assert.isArray(meta.list);
          assert.equal(meta.list.length, 1);
          assert.equal(meta.list[0], 'foo/bar');
        });
      });

      suite('many same-typed metas', () => {
        let metas = [];

        setup(() => {
          metas[0] = new CellsIronMeta({ key: 'default1', value: 'foo/bar1', });
          metas[1] = new CellsIronMeta({ key: 'default2', value: 'foo/bar2', });
          metas[2] = new CellsIronMeta({ key: 'default3', value: 'foo/bar3', });
        });

        teardown(() => {
          metas.forEach(function(meta) {
            meta.value = null;
            meta.key = null;
          });
        });

        test('all cache all meta values', () => {
          metas.forEach(function(meta) {
            assert.equal(meta.list.length, metas.length);
            assert.operator(meta.list.indexOf(meta.value), '>=', 0);
          });
        });

        test('can be unregistered individually', () => {
          metas[0].value = null;
          expect(metas[0].list.length).to.be.equal(2);
          expect(metas[0].list).to.have.members(['foo/bar2', 'foo/bar3',]);
        });

        test('can access each others value by key', () => {
          assert.equal(metas[2].byKey('default2'), metas[1].value);
        });

        test('when access to other value by key, not lose your value', () => {

          assert.equal(metas[2].byKey('default1'), metas[0].value);
          assert.equal(metas[2].value, 'foo/bar3');
        });
      });

      suite('different-typed metas', () => {
        let metasType = [];

        setup(() => {
          metasType[0] = new CellsIronMeta({ type: 'foo', key: 'foobarKey', value: 'type/foo', });
          metasType[1] = new CellsIronMeta({ type: 'bar', key: 'foobarKey', value: 'type/bar', });
        });


        teardown(() => {
          metasType.forEach(function(meta) {
            meta.value = null;
            meta.key = null;
          });
        });

        test('cache their values separately', () => {
          let fooMeta = metasType[0];
          let barMeta = metasType[1];

          expect(fooMeta.value).to.not.be.equal(barMeta.value);
          expect(fooMeta.byKey('foobarKey')).to.be.equal(fooMeta.value);
          expect(barMeta.byKey('foobarKey')).to.be.equal(barMeta.value);
        });


        test('only list values of their type', () => {
          metasType.forEach(function(meta) {
            expect(meta.list.length).to.be.equal(1);
            expect(meta.list[0]).to.be.equal(meta.value);
          });
        });
      });

      suite('metas with clashing keys', () => {
        let metaPair = [];

        setup(() => {
          metaPair[0] = new CellsIronMeta({ key: 'baz', value: 'baz/1', });
          metaPair[1] = new CellsIronMeta({ key: 'baz', value: 'baz/2', });
        });

        teardown(() => {
          metaPair.forEach(function(meta) {
            meta.value = null;
            meta.key = null;
          });
        });

        test('let the last value win registration against the key', () => {
          let registeredValue = metaPair[0].byKey(metaPair[0].key);
          let firstValue = metaPair[0].value;
          let secondValue = metaPair[1].value;
          expect(firstValue).to.be.equal(secondValue);
          expect(registeredValue).to.be.equal(secondValue);
        });
      });
    });


  </script>

</body>

</html>
