/**
@license
Copyright Â© 2016-2018 Component Kitchen, Inc. and contributors to the Elix project

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
import { dedupingMixin, } from '@cells-components/cells-lit-helpers/utils/mixin.js';

// We consider the keyboard to be active if the window has received a keydown
// event since the last mousedown event.
let keyboardActive = false;

const focusVisibleChangedListenerKey = Symbol('focusVisibleChangedListener');

function refreshFocus(element) {
  element.focusVisible = keyboardActive;
}

/**
 * Shows a focus indication if and only if the keyboard is active.
 *
 * The keyboard is considered to be active if a keyboard event has occurred
 * since the last mousedown event.
 *
 * This is loosely modeled after the proposed
 * [focus-visible](https://github.com/WICG/focus-visible) feature for CSS.
 *
* Mixin for focus visible state
* @module CellsFocusVisibleMixin
* @mixinFunction
*/
export const CellsFocusVisibleMixin = dedupingMixin(Base => {
  return class CellsFocusVisible extends Base {
    constructor() {
      super();

      // We listen to focusin/focusout instead of focus/blur because components
      // like Menu want to handle focus visiblity for the items they contain,
      // and those contained items can get the focus. Using focusin/focusout
      // lets us know whether this element *or any element it contains* has the
      // focus.
      //
      // Focus events are problematic in that they can occur during rendering:
      // if an element with the focus is updated so that its tabindex is
      // removed, it will lose focus. Since these focus handlers need to set
      // state, this could lead to setting state during rendering, which is bad.
      // To avoid this problem, we use promise timing to defer the setting of
      // state.
      this.addEventListener('focusout', () => {
        Promise.resolve().then(() => {
          this.focusVisible = false;

          // No longer need to listen for changes in focus visibility.
          document.removeEventListener('focus-visible-changed', this[focusVisibleChangedListenerKey]);
          this[focusVisibleChangedListenerKey] = null;
        });
      });

      this.addEventListener('focusin', () => {
        Promise.resolve().then(() => {
          if (this.focusVisible !== keyboardActive) {

            // Show the element as focused if the keyboard has been used.
            this.focusVisible = keyboardActive;
          }

          if (!this[focusVisibleChangedListenerKey]) {
            // Listen to subsequent changes in focus visibility.
            this[focusVisibleChangedListenerKey] = () => refreshFocus(this);
            document.addEventListener('focus-visible-changed', this[focusVisibleChangedListenerKey]);
          }
        });
      });
    }

    get focusVisible() {
      return this._focusVisible;
    }

    set focusVisible(newValue) {
      this._focusVisible = newValue;
      if (newValue) {
        this.setAttribute('focus-visible', '');
      } else {
        this.removeAttribute('focus-visible');
      }
    }
  };
});

export default CellsFocusVisibleMixin;

function updateKeyboardActive(newKeyboardActive) {
  /* istanbul ignore next */
  if (keyboardActive !== newKeyboardActive) {
    keyboardActive = newKeyboardActive;
    const event = new CustomEvent('focus-visible-changed', {
      detail: {
        focusVisible: keyboardActive,
      },
    });
    document.dispatchEvent(event);
  }
}

// Listen for top-level keydown and mousedown events.
// Use capture phase so we detect events even if they're handled.
// Use JS modules for only once call
window.addEventListener('keydown', () => {
  updateKeyboardActive(true);
}, { capture: true, });

window.addEventListener('mousedown', () => {
  updateKeyboardActive(false);
}, { capture: true, });
