import { LitElement, html, } from 'lit-element';
import { getComponentSharedStyles, } from '@cells-components/cells-lit-helpers/cells-lit-helpers.js';
import { ifDefined } from 'lit-html/directives/if-defined.js';
import { CellsSlotsContentMixin } from '@cells-components/cells-slots-content-mixin';
import { CellsFocusVisibleMixin } from '@cells-components/cells-focus-visible-mixin';
import styles from './cells-select-styles.js';
import stylesOption from './cells-option-styles.js';

function uniqueID(length = 6) {
  return `_${Math.random().toString(36).substr(2, length)}`;
}
/**
`CellsSelect` provides a base class as well as a `<cells-select>` and a `<cells-option>` custom elements with select & options functionality similar to native select. It provides an easier and convenient way to build selects with encapsulated HTML & custom styles. As it almost does not provide any styles, it's specially aimed to be extended.

As native selects, it can communicate with forms in the same document using standard form attributes. It can receive 'name' and 'form' attributes, as well as 'value' in options. It can have a 'disabled' and 'readonly' state, it can be 'required', and it can receive an 'autofocus' attribute to get focus when component is attached to the document.

## FocusVisible mixin

`CellsSelect` uses `FocusVisible mixin` from `@cells-components`. This means you can use the 'focus-visible' attribute on your component to manage ':focus' styles based on user navigation interface (keyboard/pointer).

```css
:host([focus-visible]) .button {
  ...Your focus styles...
}
```

## Form communication

To be able to communicate with **forms in the same document**, a component which extends from `CellsSelect` must implement `_select` getter in its render method.
```js
  render() {
    return html`
      <style>${this.constructor.shadyStyles}</style>
      <slot></slot>
      ${this._select}
    `;
  }
```

This way, the component will be able to use the same attributes native buttons have to customize interaction with forms: 'name', 'form', 'value' in options...

```html
<form action="formaction" method="get" target="_self">
  <custom-select name="customSelectName">
    <custom-option value="val1">Value 1</custom-option>
    <custom-option value="val2">Value 2</custom-option>
    <custom-option value="val3">Value 3</custom-option>
  </custom-select>
</form>
```

@customElement cells-select
@polymer
@LitElement
@demo demo/index.html
@appliesMixin CellsSlotsContentMixin
@appliesMixin CellsFocusVisibleMixin
 */
export class CellsSelect extends CellsSlotsContentMixin(CellsFocusVisibleMixin(LitElement)) {
  static get is() {
    return 'cells-select';
  }

  static get properties() {
    return {
      /**
       * Array of options to show, with 'text' and 'value'
       */
      items: {
        type: Array
      },

      /**
       * Label for select
       */
      label: {
        type: String
      },

      /**
       * Current value of select. Must match the value from one of the options
       */
      value: {
        type: String
      },

      /**
       * If true, select is currently disabled
       */
      disabled: {
        type: Boolean
      },

      /**
       * If true, select is required
       */
      required: {
        type: Boolean
      },

      /**
       * If true, select is readonly
       */
      readonly: {
        type: Boolean,
        reflect: true
      },

      /**
       * If true, select is currently invalid
       */
      invalid: {
        type: Boolean
      },

      /**
       * Name for select when relating to form elements
       */
      name: {
        type: String
      },

      /**
       * ID of form element the select is related with
       */
      form: {
        type: String
      },

      /**
       * Index of selected option
       */
      selectedIndex: {
        type: Number,
        attribute: 'selected-index'
      },

      /**
       * Lapse (in ms) for additional keys for focusing/selecting by writing characters
       */
      focusByCharacterTimer: {
        type: Number,
        attribute: 'focus-by-character-timer'
      },

      /**
       * If true, select is currently opened
       */
      opened: {
        type: Boolean
      },

      _formElementId: {
        type: String
      },

      _focusedOption: {
        type: Object
      },

      _selectedOption: {
        type: Object
      }
    };
  }

  constructor() {
    super();
    this.items = [];
    this.name = '';
    this.required = false;
    this.readonly = false;
    this.invalid = false;
    this.focusByCharacterTimer = 1000;
    this.opened = false;
    this._formElementId = uniqueID();
    this._focusedOption = {};
    this._rendered = false;
    this._items = [];
    this._lightNodes = [];
    this._options = [];
    this._filterByCharacter = '';
    this._slotschanges = this._slotschanges.bind(this);
    this._onKeydown = this._onKeydown.bind(this);
    this.addEventListener('slotschanges', this._slotschanges);
    this.addEventListener('keydown', this._onKeydown);
  }

  /**
   * Returns tag name (uppercase) of valid option elements for this select
   * @return {String} Tag name (uppercase) of valid option elements for this select
   */
  static get optionTag() {
    return 'CELLS-OPTION';
  }

  /**
   * Total options length
   * @return {Number} Total options length
   */
  get length() {
    return this._options.length;
  }

  /**
   * Type of select element
   * @return {String} Return 'select-one'
   */
  get type() {
    return this._formElement.type;
  }

  /**
   * Value of currently selected option. If no option is selected, returns an empty string
   * @return {String} Value of currently selected option or empty string
   */
  get value() {
    return this._selectedOption && this._selectedOption.value || '';
  }

  /**
   * Selects option matching provided value; or unselects all if no matches are found
   * @param  {String} value Value to match
   */
  set value(value) {
    this._updateValue(value);
  }

  async _updateValue(value) {
    if (!this._rendered) {
      await this.updateComplete;
    }
    if (this.value !== value) {
      const option = this._options.find(item => item.value === value);
      if (option) {
        this._selectItem(option);
      } else {
        this._unselect();
      }
    }
  }

  /**
   * Returns array of available option elements in select
   * @return {Array} Available option elements in select
   */
  get options() {
    return this._options;
  }

  /**
   * Returns currently selected option in select
   * @return {Object} Currently selected option in select
   */
  get selectedOption() {
    return this._selectedOption;
  }

  /**
   * Returns index of currently selected option
   * @return {Number} Index of currently selected option
   */
  get selectedIndex() {
    return this._selectedIndex;
  }

  /**
   * Selects option with provided index, or unselects them if index does not match any option
   * @param  {Number} index Index of option to select
   */
  set selectedIndex(index) {
    this._updateSelectedIndex(index);
  }

  async _updateSelectedIndex(index) {
    if (!this._rendered) {
      await this.updateComplete;
    }
    const oldIndex = this._selectedIndex;
    if (index !== oldIndex) {
      if (this._options[index]) {
        this._selectItem(this._options[index]);
      } else {
        this._unselect();
      }
    }
  }

  firstUpdated(changedProps) {
    /* istanbul ignore else */
    if (super.firstUpdated) {
      super.firstUpdated(changedProps);
    }
    this._rendered = true;
    this._button = this.shadowRoot.querySelector('#button');
    this._list = this.shadowRoot.querySelector('#list');
    this._formElement = this.shadowRoot.querySelector(`#${this._formElementId}`);
    this._rootNode = this.getRootNode();
    if (this._formElement) {
      this.appendChild(this._formElement);
    }
    if (this.hasAttribute('autofocus')) {
      this.focus();
    }
  }

  updated(changedProps) {
    /* istanbul ignore else */
    if (super.updated) {
      super.updated(changedProps);
    }
    if (changedProps.has('items')) {
      this._items = [...this.shadowRoot.querySelectorAll(this.constructor.optionTag.toLowerCase())];
      this._updateOptions();
    }
    if (changedProps.has('opened')) {
      if (this.opened) {
        const target = this._selectedOption || this._enabledOptions[0];
        target.focused = true;
        setTimeout(() => {
          target.focus();
        }, 0);
      }
    }
    // if (changedProps.has('_selectedOption')) {
    //   this.invalid = false;
    // }
  }

  static get shadyStyles() {
    return `
      ${styles.cssText}
      ${getComponentSharedStyles('cells-select-shared-styles')}
    `;
  }

  render() {
    return html`
      <style>${this.constructor.shadyStyles}</style>
      ${this._label}
      ${this._control}
      ${this._optionsLayer}
      ${this._select}
    `;
  }

  get _label() {
    return html`
      <span id="label" class="label" aria-hidden="true">${this.label}</span>
    `;
  }

  get _control() {
    return html`
      <button
        id="button"
        class="button"
        ?disabled="${this.disabled}"
        aria-expanded="${this.opened}"
        aria-invalid="${this.invalid}"
        aria-haspopup="listbox"
        aria-labelledby="label button"
        @click="${this._onButtonClick}">
        ${this._controlContent}
      </button>
    `;
  }

  get _controlContent() {
    return html`
      ${this._selectedOption && this._selectedOption.text}
    `;
  }

  get _optionsLayer() {
    return html`
      <div class="options-layer ${this.opened ? 'opened' : ''}">
        ${this._optionsList}
      </div>
    `;
  }

  get _optionsList() {
    return html`
      <div
        id="list"
        class="list"
        role="listbox"
        ?hidden="${false}"
        aria-labelledby="label"
        aria-readonly="${this.readonly}"
        aria-required="${this.required}"
        @click="${this._onOptionClick}"
        @option-change="${this._onOptionChange}"
        @option-focus="${this._onOptionFocus}"
        @focusout="${this._onOptionFocusout}">
        <slot></slot>
        ${this.items.map(item => this._optionItemTemplate(item))}
      </div>
    `;
  }

  _optionItemTemplate(item) {
    return html`
      <cells-option
        ?disabled="${item.disabled}"
        ?selected="${item.selected}"
        .value="${item.value}">${item.text}</cells-option>
    `;
  }

  get _select() {
    return html`
      <span class="slot-select" aria-hidden="true" tabindex="-1">
        <slot name="_select"></slot>
      </span>
      <select
        slot="_select"
        id="${this._formElementId}"
        tabindex="-1"
        name="${this.name}"
        form="${ifDefined(this.form)}"
        ?disabled="${this.disabled}"
        ?required="${this.required}"
        aria-hidden="true"
        @focus="${this.focus}"
        @invalid="${this._onInvalid}">
        <option value="${this.value}">${this.value}</option>
      </select>
    `;
  }

  /**
   * Set focus on control
   */
  focus() {
    this._button.focus();
  }

  /**
   * Returns option with specified index
   */
  item(index) {
    return this._options[index];
  }

  /**
   * Returns option matching provided name or value
   */
  namedItem(value) {
    return this._options.find(option => option.name === value || option.id === value);
  }

  _onButtonClick(ev) {
    if (!this.readonly) {
      this.opened = !this.opened;

      if (!this.opened) {
        this.focus();
      }
    }
  }

  _onOptionClick(ev) {
    const option = ev.composedPath().find(item => item.tagName === this.constructor.optionTag);
    this._selectItem(option, true);
    this.opened = false;
    this.focus();
  }

  _onOptionChange(ev) {
    const target = ev.target;
    if (target !== this._selectedOption && target.selected) {
      this._selectItem(target);
    }
  }

  _onOptionFocus(ev) {
    const focusedOption = this._enabledOptions.find(item => item.focused && item !== ev.target);
    if (focusedOption) {
      focusedOption.focused = false;
    }
    this._focusedOption = ev.target;
  }

  _onOptionFocusout() {
    setTimeout(() => {
      const newFocusedElement = this.shadowRoot.activeElement || this._rootNode.activeElement;
      if (this._options.indexOf(newFocusedElement) < 0) {
        this.opened = false;
      }
    }, 0);
  }

  _onInvalid(ev) {
    this.invalid = true;
    /**
     * Fired when element gets invalid state
     * @event invalid
     */
    this.dispatchEvent(new CustomEvent('invalid'));
  }

  _slotschanges(ev) {
    ev.stopPropagation();
    ev.preventDefault();
    if (ev.detail.slotName === '' && ev.detail.contentSlots.length) {
      const nodes = [];
      ev.detail.contentSlots.forEach((item, index) => {
        if (
          item.assignedNodes.tagName === this.constructor.optionTag
        ) {
          nodes.push(item.assignedNodes);
        }
      });
      this._lightNodes = nodes;
      this._updateOptions();
    }
  }

  _fireEvents() {
    this.invalid = false;
    /**
     * Fired when user updates selected option
     * @event change
     */
    this.dispatchEvent(new CustomEvent('change', {
      bubbles: true
    }));
  }

  _updateOptions() {
    this._options = this._lightNodes.concat(this._items);
    this._enabledOptions = this._options.filter(item => !item.disabled);
    const selected = this._options.find(item => item.selected);
    if (selected) {
      this._selectItem(selected);
    } else {
      this._unselect();
    }
    this.requestUpdate();
  }

  _selectItem(item, fireEvents) {
    if (item.disabled || item === this._selectedOption) {
      return;
    }
    const index = this._options.indexOf(item);
    if (!this._options[index]) {
      return;
    }
    if (this._selectedOption) {
      this._selectedOption.selected = false;
    }
    if (this._options[index] && !this._options[index].selected) {
      this._options[index].selected = true;
    }
    this._selectedLabel = this._options[index].text;
    this._selectedIndex = index;
    this._selectedOption = this._options[index];

    if (fireEvents) {
      this._fireEvents();
    }
  }

  _unselect() {
    if (this._selectedOption) {
      this._selectedOption.selected = false;
    }
    this._selectedIndex = -1;
    this._selectedOption = this._options[this._selectedIndex];
  }

  _onKeydown(ev) {
    if (ev.key) {
      const key = ev.key.toLowerCase();

      if (/^[a-z0-9*]$/.test(key)) {
        this._focusByCharacter(key);
        return;
      }

      if (this.opened) {
        this._keyAction(ev, key);
      }
    }
  }

  _keyAction(ev, key) {
    switch(key) {
      case 'escape':
        ev.preventDefault();
        this.opened = false;
        this.focus();
        return;
      case 'enter':
      case ' ':
        ev.preventDefault();
        this._selectItem(this._options.find(item => item.focused), true);
        this.opened = false;
        this.focus();
        return;
      case 'arrowdown':
      case 'arrowup':
        ev.preventDefault();
        if (this._enabledOptions.length > 1) {
          this._focusByArrow(key);
          return;
        }
      case 'home':
      case 'end':
      case 'pageup':
      case 'pagedown':
        ev.preventDefault();
        if (this._enabledOptions.length > 0) {
          const item = key === 'home' || key === 'pageup' ? 0 : this._enabledOptions.length - 1;
          const focusedOption = this._enabledOptions.find(item => item.focused);
          if (focusedOption) {
            focusedOption.focused = false;
          }
          this._enabledOptions[item].focused = true;
          return;
        }
    }
  }

  _focusByCharacter(key) {
    clearTimeout(this._focusByCharacterTimer);
    this._focusByCharacterTimer = setTimeout(() => {
      this._filterByCharacter = '';
    }, this.focusByCharacterTimer);
    const newFilter = `${this._filterByCharacter}${key}`;
    const filteredOptions = this._enabledOptions.filter(item => {
      return item.text.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').indexOf(newFilter) === 0
    });
    if (filteredOptions.length) {
      if (this.opened) {
        filteredOptions[0].focused = true;
      } else if (filteredOptions[0] !== this._selectedOption) {
        this._selectItem(filteredOptions[0], true);
      }
    }
    this._filterByCharacter = newFilter;
  }

  _focusByArrow(key) {
    const focusedOption = this._enabledOptions.find(item => item.focused);
    const lastItemIndex = this._enabledOptions.length - 1;
    const keyAdvance = key === 'arrowdown';

    if (!focusedOption) {
      const index = keyAdvance ? 0 : lastItemIndex;
      this._enabledOptions[index].focused = true;
      return;
    }

    const focusedIndex = this._enabledOptions.indexOf(focusedOption);
    const validMovement = keyAdvance ? focusedIndex < lastItemIndex : focusedIndex > 0;

    if (validMovement) {
      focusedOption.focused = false;
      const newIndex = keyAdvance ? focusedIndex + 1 : focusedIndex - 1;
      this._enabledOptions[newIndex].focused = true;
    }
  }
}

window.customElements.define(CellsSelect.is, CellsSelect);

/**
`cells-option` is a custom element aimed to be used inside `cells-select` custom elements. It provides similar functionality to native 'option' tags, but it can provide its own styling and properties. So, it's specially aimed to be extended for encapsulating styles.
 */
export class CellsOption extends LitElement {
  static get is() {
    return 'cells-option';
  }

  static get properties() {
    return {
      /**
       * Name for option
       */
      name: {
        type: String
      },

      /**
       * If true, option is disabled
       */
      disabled: {
        type: Boolean
      },

      /**
       * If true, option is selected
       */
      selected: {
        type: Boolean
      },

      /**
       * Value for option
       */
      value: {
        type: String
      },

      /**
       * If true, option is focused
       */
      focused: {
        type: Boolean
      }
    };
  }

  get text() {
    return this.textContent;
  }

  constructor() {
    super();
    this.disabled = false;
    this.selected = false;
    this.focused = false;
    this.addEventListener('mouseenter', this._onMouseEnter.bind(this));
    this.addEventListener('mouseleave', this._onMouseLeave.bind(this));
  }

  connectedCallback() {
    super.connectedCallback();
    this.setAttribute('role', 'option');
  }

  updated(changedProps) {
    /* istanbul ignore else */
    if (super.updated) {
      super.updated(changedProps);
    }
    if (changedProps.has('disabled')) {
      this.setAttribute('aria-disabled', this.disabled.toString());
    }
    if (changedProps.has('selected')) {
      this.setAttribute('aria-selected', this.selected.toString());
    }
    if (changedProps.has('selected') || changedProps.has('value')) {
      /**
       * Fired when selected or value changes
       * @event option-change
       */
      this.dispatchEvent(new CustomEvent('option-change', {
        bubbles: true,
        detail: {
          selected: this.selected,
          disabled: this.disabled,
          value: this.value
        }
      }));
    }
    if (changedProps.has('focused')) {
      this.setAttribute('tabindex', this.focused ? '0' : '-1');
      if (this.focused) {
        this.focus();
        /**
         * Fired when focused is set to true
         * @event option-focus
         */
        this.dispatchEvent(new CustomEvent('option-focus', {
          bubbles: true
        }));
      }
    }
  }

  static get shadyStyles() {
    return `
      ${stylesOption.cssText}
      ${getComponentSharedStyles('cells-option-shared-styles')}
    `;
  }

  render() {
    return html`
      <style>${this.constructor.shadyStyles}</style>
      <span><slot></slot></span>
    `;
  }

  _onMouseEnter() {
    if (!this.disabled) {
      this.focused = true;
    }
  }

  _onMouseLeave() {
    this.focused = false;
  }
}

window.customElements.define(CellsOption.is, CellsOption);
